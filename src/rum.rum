malloc := (size: u64) -> *any;

exit := (s: int) -> void;

fopen := (s: string, mod: string) -> *int;
fseek := (f: *int, offset: u64, whence: u32) -> int; // SEEK_END == 2, SEEK_SET == 0
ftell := (f: *int) -> int;
fread := (buf: string, size: int, nmemb: int, f: *int) -> int;

atoi := (s: string) -> int;

printf := (T: string, s: ...any)->void;

// LLVM
LLVMContextCreate := () -> *any;
LLVMModuleCreateWithNameInContext := (name: string, c: *any) -> *any;
LLVMPrintModuleToString := (m: *any) -> string;
LLVMCreateBuilderInContext := (c: *any) -> *any;
LLVMDisposeBuilder := (b: *any) -> void;

LLVMGetNamedFunction := (m: *any, name: string) -> *any;
LLVMGetReturnType := (f: *any) -> *any;
LLVMBuildCall := (b: *any, f: *any, args: *any, count: int, name: string) -> *any;
LLVMInstructionEraseFromParent := (instr: *any) -> void;
LLVMGetElementType := (t: *any) -> *any;
LLVMGetTypeKind := (t: *any) -> int;
/*
  void : 0
  function: 9
  ptr: 12
*/

LLVMInt1TypeInContext := (c: *any) -> *any;
LLVMInt8TypeInContext := (c: *any) -> *any;
LLVMInt16TypeInContext := (c: *any) -> *any;
LLVMInt32TypeInContext := (c: *any) -> *any;
LLVMInt64TypeInContext := (c: *any) -> *any;
LLVMVoidTypeInContext := (c: *any) -> *any;
LLVMPointerType := (elemntType: *any, addresspace: u64) -> *any;
LLVMFunctionType := (returnType: *any, paramTypes: **any, paramCount: u64, isVarArg: bool) -> *any;

LLVMTypeOf := (val: *any) -> *any;
LLVMDumpValue := (val: *any) -> void;
LLVMDumpType := (val: *any) -> void;

LLVMAddFunction := (m: *any, name: string, ftype: *any) -> *any;
LLVMAppendBasicBlockInContext := (c: *any, f: *any, name: string)-> *any;
LLVMCreateBasicBlockInContext := (c: *any, name: string) -> *any;
LLVMAppendExistingBasicBlock := (f: *any, bb: *any) -> void;
LLVMGetParam := (f: *any, ind: u64) -> *any;
LLVMSetValueName2 := (v: *any, name: string, size: u64) -> void;

LLVMPositionBuilder := (b: *any, bb: *any, inst: *any) -> void;
LLVMBuildRet := (b: *any, v: *any) -> void;
LLVMBuildRetVoid := (b: *any) -> void;
LLVMBuildAlloca := (b: *any, type: *any, name: string) -> *any;
LLVMBuildStore := (b: *any, val: *any, ptr: *any) -> void;
LLVMBuildLoad := (b: *any, ptr: *any, name: string) -> *any;
LLVMBuildIntToPtr := (b: *any, val: *any, dest: *any, name: string) -> *any;
LLVMBuildIntCast2 := (b: *any, val: *any, dest: *any, signed: bool, name: string) -> *any;
LLVMBuildBitCast := (b: *any, val: *any, dest: *any, name: string) -> *any;
LLVMBuildICmp := (b: *any, op: int, lhs: *any, rhs: *any, name: string) -> *any;
/*
  * 32,  EQ
  * 33,  NEQ
  * 34,  UGT
  * 35,  UGE
  * 36,  ULT
  * 37,  ULE
  * 38,  SGT
  * 39,  SGE
  * 40,  SLT
  * 41,  SLE
*/
LLVMBuildBinOp := (b: *any, op: int, lhs: *any, rhs: *any, name: string) -> *any;
/*
  * Standard Binary Operators
   LLVMAdd            = 8,
   LLVMFAdd           = 9,
   LLVMSub            = 10,
   LLVMFSub           = 11,
   LLVMMul            = 12,
   LLVMFMul           = 13,
   LLVMUDiv           = 14,
   LLVMSDiv           = 15,
   LLVMFDiv           = 16,
   LLVMURem           = 17,
   LLVMSRem           = 18,
   LLVMFRem           = 19,
 
  * Logical Operators
   LLVMShl            = 20,
   LLVMLShr           = 21,
   LLVMAShr           = 22,
   LLVMAnd            = 23,
   LLVMOr             = 24,
   LLVMXor            = 25,
*/

LLVMConstInt := (t: *any, v: *any, signed: bool) -> *any;
LLVMBuildGlobalStringPtr := (b: *any, str: string, name: string) -> *any;
LLVMAddGlobal := (m: *any, ty: *any, name: string)-> *any;
LLVMConstNamedStruct := (ty: *any, val: *any, count: int) -> *any;
LLVMSetInitializer := (gv: *any, val: *any) -> void;
LLVMSetGlobalConstant := (gv: *any, isConst: bool) -> void;
LLVMGetNamedGlobal := (m: *any, name: string) -> *any;
LLVMConstBitCast := (val: *any, ty: *any) -> *any;

LLVMStructCreateNamed := (c: *any, name: *string) -> *any;
LLVMStructSetBody := (t: *any, types: *any, count: int, packed: bool) -> void;

LLVMBuildInBoundsGEP2 :=(b : *any, t: *any, ptr: *any, ind: *any, ind_count: int, name: string) -> *any;
LLVMBuildStructGEP2 :=(b : *any, t: *any, ptr: *any, ind: int, name: string) -> *any;

LLVMWriteBitcodeToFile := (m: *any, path: string) -> int;
LLVMSetTarget := (m: *any, triple: string) -> void;
LLVMSetDataLayout := (m: *any, dl: string) -> void;
LLVMGetModuleDataLayout := (m: *any) -> *any;
LLVMSizeOfTypeInBits := (td: *any, ty: *any) -> int;

LLVMGetInsertBlock := (b: *any) -> *any;
LLVMGetBasicBlockParent := (bb: *any) -> *any;
LLVMGetFirstBasicBlock := (f: *any) -> *any;
LLVMGetFirstInstruction := (bb: *any) -> *any;
LLVMBuildCondBr := (b: *any, cond: *any, bt: *any, bf: *any) -> *any;
LLVMBuildBr := (b: *any, bb: *any) -> *any;
LLVMGetBasicBlockTerminator := (bb: *any) -> *any; // instruction
LLVMGetInstructionOpcode := (inst: *any) -> int;

// Helper

CompileLLVM := (m :* any, path: string) -> void;

DBGInfo: struct{
  pos: int;
  line: int;
}

printDBGandExit := (d: *DBGInfo)-> void{
  printf("line: %d, pos: %d\n", d.line, d.pos);
  exit(1);
  return;
}

Names: struct{
  name: string;
  next: *Names;
  payload: *any;
}

BB: struct{
  prev: *BB;
  names: *Names;
}

CC: struct{
  context: *any;
  module: *any;
  builder: *any;
  lastB: *BB;
  structNum: int;
}

TypeType: enum{
  namedT = 0, // named type (mostly struct, including interface and enum as well)
  intT = 1,
  uintT = 2,
  floatT = 3,
  boolT = 4,
  stringT = 5,
  pointerT = 6,
  voidT = 7,
  funcT = 8,
  anyT = 9,
  enumT = 10,
}

Type: struct{
  type: TypeType;
  payload: *any;
  dbg: *DBGInfo;
}

SType: enum{
  returnT = 0, // (value,,)
  declT = 1, // (name, type, expr)
  assignT = 2, // (id, val,)
  memAssignT = 3, // (expr, val, ) member is handled in expression
  fcallT = 4, // (id, args, )
  ifT = 5, // (expr, st1, st2)
  whileT = 6, // (expr, st, )
  codeBlockT = 7, // (first,,) {}
  ptrAssignT = 8, //(alloca, val,)
  funcDefT = 9, // (id, type, first)
  funcSignT = 10, // (id, type,)
  structDefT = 11, // (id, variable decl, struct_num)
  argT = 12, //(val,,)
  interfaceDefT = 13, //(id, method decl,)
  methodCallT = 14, //(methodname, args, base expr)
  enumDefT = 15, // (id, members, )
  enumMemT = 16, // (id, val,)
}

Statement: struct {
  type: SType;
  p1: *any;
  p2: *any;
  p3: *any;
  next: *Statement;
  dbg: *DBGInfo;
}

VariablePayload: struct{
  alloc : *any;
  decl : *Statement;
}

EType: enum{
  varE = 0, // variable(id, ,)
  memE = 1, // member(expr, id, )
  binE = 2, // binary expression(e1, op, e2)
  binOrderE = 3, // binary expression (requires reordering in parent) REMOVE??
  cIntE = 4, // const int(val, ,)
  cStrE = 5, // const string(val, ,)
  ptrE = 6, // ptr (expr,,)
  fcallE = 7, // fcall(id, args,)
  sizeE = 8, // sizeof(type,,)
  notE = 9, // not(expr,,)
  methodCallE = 10, // methodcall(methodname, args, base expression)
  baseE = 11, // baseof(expr,,) // reverse of ptr
  cCharE = 12, // const char(val,,)
  instanceE, // (id, type, )
}

OpCode: enum {
  eq = 0, // ==
  add = 1, // +
  minus = 2, // -
  mult = 3, // *
  div = 4, // /
  rem = 5, // %
  neq = 6, // !=
  lt = 7, // <
  lte = 8, // <=
  gt = 9, // >
  gte = 10, // >=
}

Expression: struct{
  type: EType;
  p1: *any;
  p2: *any;
  p3: *any;

  prec: int; // precident
  dbg: *DBGInfo;
}

FunctionType: struct{
  returnType: *Type;
  first: *Statement; // variable decl
}

TokenType: enum{
  TEOF = 0, // EOF
  TID = 1, // id
  TCOL = 2, // :
  TDEF = 3, // :=
  TLPAR = 4, // (
  TRPAR = 5, // )
  TCOMMA = 6, // ,
  TDOT = 7, // .
  T3DOT = 8, // ...
  TDASH = 9, // -
  TARROW = 10, // ->
  TSEM = 11, // ;
  TSTAR = 12, // *
  TFSLASH = 13, // /
  TLCB = 14, // {
  TRCB = 15, // }
  TNUM = 16, // num
  TEQ = 17, // =
  TEQEQ = 18, // ==
  TPLUS = 19, // +
  TSTRV = 20, // string value
  TINT = 21, // int
  TRET = 22, // return
  TIF = 23, // if
  TWHILE = 24, // while
  TELSE = 25, // else
  TSTR = 26, // string
  TANY = 27, // any
  TSTRUCT = 28, // struct
  TVOID = 29, // void
  TU8 = 30, // u8
  TU16 = 31, // u16
  TU32 = 32, // u32
  TU64 = 33, // u64
  TS8 = 34, // s8
  TS16 = 35, // s16
  TS32 = 36, // s32
  TS64 = 37, // s64
  TF32 = 38, // f32
  TF64 = 39, // f64
  TBOOL = 40, // bool
  TPERC = 41, // %
  TSIZE = 42, // sizeof
  TNEQ = 43, // !=
  TNOT = 44, // !
  TLT = 45, // <
  TLTE = 46, // <=
  TGT = 47, // >
  TGTE = 48, // >=
  TINTERFACE = 49, // interface
  TENUM = 50, // enum
  TCHAR = 51, // character
  TINSTANCEOF,
  TAND, // &
}

Token: struct {
  type: TokenType; // We don't have enums yet
  payload: *any;
  dbg: *DBGInfo;
}

Lexer : struct {
  ptr    : **Token;
  count  : int;
  offset : int;
  dbg: *DBGInfo;
  line : int;
}

streq := (s1: *u8, s2: *u8) -> bool{
  counter := 0;
  while(1){
    if(*(s1+ counter) != *(s2+counter)){
      return 0;
    }
    if(*(s1+counter) == 0)
      return 1;

    counter = counter + 1;
  }

  return 0; // unreachable
}

strlen := (s1: *u8) -> u64{
  size := 0;
  while(1){
    if((*(s1+size)) == 0)
      return size;
    size = size + 1;
  }
  return 0; // unreachable
}

strcat := (s1: *u8, s2: *u8) -> *u8{
  size := strlen(s1) + strlen(s2) + 1;
  ans : *u8 = malloc(size * sizeof u8);
  ptr := 0;
  ptr2 := 0;
  while(*(s1+ptr) != 0){
    *(ans+ptr) = *(s1+ptr);
    ptr = ptr + 1;
  }
  while(*(s2+ptr2) != 0){
    *(ans+ptr) = *(s2+ptr2);
    ptr = ptr + 1;
    ptr2 = ptr2 + 1;
  }
  *(ans+ptr) = 0;
  return ans;
}

is_alpha := (c: u8) -> bool{
  if(c >= 'a')
    if(c <= 'z')
      return 1;
  if(c >= 'A')
    if(c <= 'Z')
      return 1;
  return 0;
}

is_numeric := (c: u8) -> bool{
  if(c >= '0')
    if(c <= '9')
      return 1;
  return 0;
}

is_alphanumeric := (c: u8) -> bool{
  if(c == '_') // underline
    return 1;

  if(is_alpha(c))
    return 1;

  return is_numeric(c);
}

lexer_skip_ws := (l: *Lexer, buf: *u8, offset: int) -> int {
  while(1){
    is_ws := 0;

    c : u8 = *(buf + offset);


    if(c == 10){ // \n
      is_ws = 1;
      l.line = l.line + 1;
    }

    if(c == 32) // space
      is_ws = 1;

    if(c == 9) // tab
      is_ws = 1;

    if(is_ws==0)
      return offset;

    offset = offset + 1;
  }

  return 0; // Never reaches here, just to prevent segfault in compile
}

lex_id := (buf: *u8, offset: int) -> int {
  end := offset;
  while(is_alphanumeric(*(buf+end))){
    end = end + 1;
  }
  return end;
}

lex_num := (buf: *u8, offset: int) -> int {
  end := offset;
  while(is_numeric(*(buf+end))){
    end = end + 1;
  }
  return end;
}

lex_str := (buf: *u8, offset: int) -> int {
  end := offset+1;
  while(1){
    if(*(buf+end) == '"'){ // "
      return end + 1;
    }
    if(*(buf+end) == '\n'){ // newline
      printf("Unclosed string literal\n");
      exit(1);
    }

    if(*(buf+end) == '\\'){ // \ 
      end = end + 1; // skip the next one, whatever it might be.
    }
    end = end + 1;
  }

  return 0; // won't reach here
}

resolve_escape := (c: u8) -> u8 {
  if(c == 'n'){// \n
    return '\n';
  } else { // TODO handle tab, etc, \' and \"
    return c;
  }
}

handle_str := (buf: *u8, offset: int, end: int) -> string {
  ind := 0;
  offset = offset + 1; // ignore "
  end = end - 1; // ignore "
  size := end - offset;
  // TODO debug size
  out : *u8 = malloc(2 * (size+4)); // not sure why we need +4 here.

  while(end - offset){
    *(out + ind) = *(buf + offset);

    if(*(buf + offset) == '\\'){
      // handle special cases
      offset = offset + 1;
      *(out + ind) = resolve_escape(*(buf+offset));
    }

    offset = offset + 1;
    ind = ind + 1;
  }

  *(out + ind) = 0;

  return out;
}

strcp := (buf: *u8, start: int, end: int) -> string{
  out : *u8 = malloc(sizeof u64 * (end - start));
  counter := start;
  while(counter != end){
    *(out + (counter - start)) = *(buf + counter);
    counter = counter + 1;
  }
  *(out + (end - start)) = 0; // '\0'
  return out;
}

parse_num := (buf: *u8, start: int, end: int) -> int{
  str := strcp(buf, start, end);
  return atoi(str);
}

copy_debug_info := (d: *DBGInfo) -> *DBGInfo {
  ans : *DBGInfo = malloc(sizeof DBGInfo);
  ans.pos = d.pos;
  ans.line = d.line;
  return ans;
}

lexer := (buf: *u8) -> *Lexer{
  l : *Lexer;

  l = malloc(sizeof Lexer);
  l.count = 0;
  l.line = 1;
  l.dbg = malloc(sizeof DBGInfo);
  l.ptr = malloc(9000000 * sizeof Token);

  offset := 0;

  // we don't have a break yet
  while_cond := 1;
  while(while_cond){
    offset = lexer_skip_ws(l, buf, offset);
    l.dbg.pos = offset;
    l.dbg.line = l.line;

    if(*(buf+offset) == 0){
      // EOF
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TEOF;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      while_cond = 0;
    } else if(is_alpha(*(buf+offset))){
      end := lex_id(buf, offset); 
      id := strcp(buf, offset, end);
      offset = end;
      // capture different tokens
      if(streq(id, "int")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TINT;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "return")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TRET;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "if")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TIF;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "while")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TWHILE;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "else")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TELSE;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "string")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TSTR;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "any")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TANY;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "struct")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TSTRUCT;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "interface")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TINTERFACE;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "enum")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TENUM;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "void")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TVOID;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "u8")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TU8;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "u16")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TU16;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "u32")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TU32;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "u64")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TU64;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "s8")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TS8;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "s16")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TS16;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "s32")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TS32;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "s64")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TS64;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "f32")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TF32;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "f64")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TF64;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "bool")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TBOOL;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "sizeof")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TSIZE;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else if(streq(id, "instanceof")){
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TINSTANCEOF;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else {
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TID;
        t.payload = id;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      }
    } else if(is_numeric(*(buf+offset))){
      end := lex_num(buf, offset); 
      num := parse_num(buf, offset, end);
      offset = end;
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TNUM;
      t.payload = num;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
    } else if(*(buf+offset) == '!'){ // !
      offset = offset + 1;
      if(*(buf+offset) == '='){// !=
        offset = offset + 1;
        t: *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TNEQ;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else { // !
        t: *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TNOT;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      }
    } else if(*(buf+offset) == '<'){ // <
      offset = offset + 1;
      if(*(buf+offset) == '='){// <=
        offset = offset + 1;
        t: *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TLTE;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else { // <
        t: *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TLT;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      }
    } else if(*(buf+offset) == '>'){ // >
      offset = offset + 1;
      if(*(buf+offset) == '='){// >=
        offset = offset + 1;
        t: *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TGTE;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else { // >
        t: *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TGT;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      }
    } else if(*(buf+offset) == ':'){ // :
      offset = offset + 1;
      if(*(buf+offset) == '=') { // :=
        offset = offset + 1;
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TDEF;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      } else { // only :
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TCOL;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
      }
    } else if(*(buf+offset) == '('){ // lpar
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TLPAR;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == ')'){ // rpar
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TRPAR;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == ','){ // ,
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TCOMMA;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == '&'){ // &
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TAND;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == '.'){ // .
      // we don't have and, so we multiply them
      tmp_bool : bool = *(buf+offset+1) == *(buf+offset+2);
      tmp_bool2 : bool = *(buf+offset+1) == 46;
      if(tmp_bool * tmp_bool2){ // ...
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.T3DOT;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
        offset = offset + 3;
      } else {
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TDOT;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
        offset = offset + 1;
      }
    } else if(*(buf+offset) == '-'){ // -
      if(*(buf+offset+1) == '>'){ // ->
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TARROW;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
        offset = offset + 2;
      } else {
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TDASH;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
        offset = offset + 1;
      }
    } else if(*(buf+offset) == ';'){ // ;
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TSEM;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == '*'){ // *
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TSTAR;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == '/'){ // /
      if (*(buf+offset +1) == '*') {
        // multiline comment
        whilecond := 1;
        while(whilecond){
          offset = offset +1;
          if(*(buf+offset) == '\n')
            l.line = l.line + 1;
          if(*(buf+offset) == '*'){
            offset = offset +1;
            if(*(buf+offset) == '/'){
              whilecond = whilecond - 1;
            }
            if(*(buf+offset) == '\n')
              l.line = l.line + 1;
          }
          if(*(buf+offset) == '/'){
            offset = offset +1;
            if(*(buf+offset) == '*'){
              whilecond = whilecond + 1;
            }
          }
        }
      } else if(*(buf+offset+1) == '/'){
        // comment
        offset = offset + 2;
        while(*(buf+offset) != '\n')
          offset = offset + 1;
      } else {
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TFSLASH;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
        offset = offset + 1;
      }
    } else if(*(buf+offset) == '{'){ // {
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TLCB;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == '}'){ // }
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TRCB;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == '+'){ // +
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TPLUS;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == '%'){ // %
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TPERC;
      t.payload = 0;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
      offset = offset + 1;
    } else if(*(buf+offset) == '='){ // =
      if(*(buf+offset+1) == '='){ // ==
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TEQEQ;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
        offset = offset + 2;
      } else {
        t : *Token = malloc(sizeof Token);
        t.dbg = copy_debug_info(l.dbg);
        t.type = TokenType.TEQ;
        t.payload = 0;
        *(l.ptr + l.count) = t;
        l.count = l.count + 1;
        offset = offset + 1;
      }
    } else if(*(buf+offset) == '"') { // "
      end := lex_str(buf, offset);
      str := handle_str(buf, offset, end);
      offset = end;
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TSTRV;
      t.payload = str;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
    
    } else if(*(buf+offset) == '\''){ // '
      // single char OR escaped char
      offset = offset + 1;
      // is it escape?
      ch : u8 = *(buf + offset);
      offset = offset + 1;
      if(ch == '\\'){// escape
        ch = resolve_escape(*(buf+offset));
        offset = offset + 1;
      }
      if(*(buf+offset) != '\''){
        printf("Unclosed character token at: ");
        offset = offset - 5;
        counter := 80;
        while(counter){
          printf("%c", *(buf+(offset+30-counter)));
          counter = counter - 1;
        }
        printf("\n");
        printDBGandExit(l.dbg);
      }
      offset = offset + 1;
      t : *Token = malloc(sizeof Token);
      t.dbg = copy_debug_info(l.dbg);
      t.type = TokenType.TCHAR;
      t.payload = ch;
      *(l.ptr + l.count) = t;
      l.count = l.count + 1;
    } else {
      while_cond = 0; // break!
      counter := 30;
      printf("Could not understand token %d, at: ", *(buf+(offset+30-counter)));
      while(counter){
        printf("%c", *(buf+(offset+30-counter)));
        counter = counter - 1;
      }
      printf("\n");
    }
  }

  return l;
}

lexer_pop := (l : *Lexer) -> *Token{
  l.offset = l.offset + 1;
  return *(l.ptr + l.offset -1);
}

lexer_peep := (l : *Lexer) -> *Token{
  return *(l.ptr + l.offset);
}

lexer_expect := (l : *Lexer, t: int, description: string) -> bool{
  tn : *Token = lexer_pop(l);
  tk := tn.type;
  if (tk == t) return 0;

  printf("On token %d\n", l.offset);
  printf("Expected to see %s, but saw %d\n", description, tk);
  l.offset = l.count;
  printDBGandExit(tn.dbg);
  return 1;
}

parse_type := (l: *Lexer) -> *Type{
  tn := lexer_pop(l);
  ans : *Type = malloc(sizeof Type);
  ans.dbg = copy_debug_info(tn.dbg);
  if(tn.type == TokenType.TLPAR){
    ft: *FunctionType = malloc(sizeof FunctionType);
    ft.first = 0;
    prev: *Type = 0;
    tn := lexer_peep(l);
    whilecond := tn.type != TokenType.TRPAR;
    while(whilecond){
      tmp : *Type = parse_type(l);
      tn = lexer_peep(l);
      if(tn.type == TokenType.T3DOT){
        // vararg, TODO
        tn = lexer_pop(l);
      }
      if(tn.type == TokenType.TCOMMA){
        whilecond = 1;
        tn = lexer_pop(l);
      } else {
        whilecond = 0;
      }
    }

    lexer_expect(l, TokenType.TRPAR, ")");
    lexer_expect(l, TokenType.TARROW, "->");

    ft.returnType = parse_type(l);

    ans.type = TypeType.funcT;
    ans.payload = ft;
    return ans;
  }
  if(tn.type == TokenType.TSTR){
    ans.type = TypeType.stringT;
    ans.payload = 0;
    return ans;
  }
  if(tn.type == TokenType.TVOID){
    ans.type = TypeType.voidT;
    ans.payload = 0;
    return ans;
  }
  if(tn.type == TokenType.TU8){
    ans.type = TypeType.uintT;
    ans.payload = 8;
    return ans;
  }
  if(tn.type == TokenType.TU16){
    ans.type = TypeType.uintT;
    ans.payload = 16;
    return ans;
  }
  if(tn.type == TokenType.TU32){
    ans.type = TypeType.uintT;
    ans.payload = 32;
    return ans;
  }
  if(tn.type == TokenType.TU64){
    ans.type = TypeType.uintT;
    ans.payload = 64;
    return ans;
  }
  if(tn.type == TokenType.TS8){
    ans.type = TypeType.intT;
    ans.payload = 8;
    return ans;
  }
  if(tn.type == TokenType.TS16){
    ans.type = TypeType.intT;
    ans.payload = 16;
    return ans;
  }
  if(tn.type == TokenType.TS32){
    ans.type = TypeType.intT;
    ans.payload = 32;
    return ans;
  }
  if(tn.type == TokenType.TS64){
    ans.type = TypeType.intT;
    ans.payload = 64;
    return ans;
  }
  if(tn.type == TokenType.TF32){
    ans.type = TypeType.floatT;
    ans.payload = 32;
    return ans;
  }
  if(tn.type == TokenType.TF64){
    ans.type = TypeType.floatT;
    ans.payload = 64;
    return ans;
  }
  if(tn.type == TokenType.TBOOL){
    ans.type = TypeType.boolT;
    ans.payload = 0;
    return ans;
  }
  if(tn.type == TokenType.TINT){
    ans.type = TypeType.intT;
    ans.payload = 0;
    return ans;
  }
  if(tn.type == TokenType.TID){
    ans.type = TypeType.namedT;
    ans.payload = tn.payload;
    return ans;
  }
  if(tn.type == TokenType.TANY){
    ans.type = TypeType.anyT;
    return ans;
  }

  // pointer *
  if(tn.type == TokenType.TSTAR){
    ans.type = TypeType.pointerT;
    ans.payload = parse_type(l);
    return ans;
  }

  printf("Expected to see type, but saw %d\n", tn.type);
  printDBGandExit(tn.dbg);
  return 0;
}

parse_expr := (l: *Lexer) -> *Expression;
parse_expr_rec := (l: *Lexer, last: int) -> *Expression;

parse_fcall_args := (l: *Lexer) -> *Statement{
  nt : *Token = lexer_peep(l);
  ans : *Statement = 0;
  prev : *Statement = 0;
  while(nt.type != TokenType.TRPAR){
    val := parse_expr(l);
    tmp : *Statement = malloc(sizeof Statement);
    tmp.dbg = copy_debug_info(nt.dbg);
    tmp.type = SType.argT;
    tmp.p1 = val;
    tmp.next = 0;
    if(ans == 0)
      ans = tmp;
    if(prev)
      prev.next = tmp;
    prev = tmp;
    nt = lexer_peep(l);
    // ,
    if(nt.type != TokenType.TCOMMA){
      if(nt.type != TokenType.TRPAR){
        printf("Expected to see , or ), saw %d\n", nt.type);
        l.offset = l.count;
        printDBGandExit(nt.dbg);
        return 0;
      }
    } else {
      lexer_pop(l);
    }
  }
  lexer_pop(l); // pop the )

  return ans;
}

parse_exp_val:=(l: *Lexer) -> *Expression{
  // check ( or *
  // GET EXPR
  // EXPECT )
  tn := lexer_pop(l);
  ans : *Expression = malloc(sizeof Expression);
  ans.dbg = copy_debug_info(tn.dbg);

  if(tn.type == TokenType.TLPAR){ // (
    e := parse_expr(l);
    e.prec = 0;
    lexer_expect(l, TokenType.TRPAR, ")");
    tn = lexer_peep(l);
    if(tn.type == TokenType.TDOT){ // .
      lexer_pop(l);
      tn = lexer_peep(l);
      lexer_expect(l, TokenType.TID, "id"); // member
      ans.type = EType.memE;
      ans.p1 = e;
      ans.p2 = tn.payload;
      return ans;
    }
    return e;
  }

  if(tn.type == TokenType.TSTAR){ // *
    v : *Expression = parse_exp_val(l);
    // check to ensure it is not const
    if((v.type == EType.cIntE) + (v.type == EType.cStrE)){
      printf("Pointer is pointing to an expression %d\n", v.type);
      printDBGandExit(v.dbg);
    }
    ans.type = EType.ptrE;
    ans.p1 = v;
    return ans;
  }

  if(tn.type == TokenType.TAND){// &
    v : *Expression = parse_exp_val(l);
    ans.type = EType.baseE;
    ans.p1 = v;
    return ans;
  }

  if(tn.type == TokenType.TNOT){// !
    v : *Expression = parse_exp_val(l);
    ans.type = EType.notE;
    ans.p1 = v;
    return ans;
  }

  // TODO handle negative values

  if(tn.type == TokenType.TID){ // id
    // TODO some of these should be post value, not post id, ex: member and method call and instance of
    /*
        Converting to this style would eliminate the need for a while here.
    */
    id := tn.payload;
    // EXPECT ID
    // CHECK FOR . ID
    tn = lexer_peep(l);
    if(tn.type == TokenType.TDOT){ // member value
      ans.type = EType.varE;
      ans.p1 = id;
      while(tn.type == TokenType.TDOT){
        lexer_pop(l);
        tn2 := lexer_peep(l);
        lexer_expect(l, TokenType.TID, "id");
        tmp : *Expression = malloc(sizeof Expression);
        tmp.dbg = copy_debug_info(tn2.dbg);
        tmp.type = EType.memE;
        tmp.p1 = ans;
        tmp.p2 = tn2.payload;
        ans = tmp;
        tn = lexer_peep(l);
      }
      if(tn.type == TokenType.TLPAR){// method call
        lexer_pop(l);
        tmp : *Expression = ans;

        // Person.Account.Email.format();
        // p1: Person.Account.Email

        args : *Statement = malloc(sizeof Statement);
        args.dbg = copy_debug_info(tn.dbg);
        args.type = SType.argT;
        args.p1 = tmp.p1;
        args.next = parse_fcall_args(l);

        ans = malloc(sizeof Expression);
        ans.dbg = copy_debug_info(tn.dbg);
        ans.type = EType.methodCallE;
        ans.p1 = tmp.p2;
        ans.p2 = args;
        ans.p3 = tmp.p1;
        return ans;
      }
      return ans;
    } else if(tn.type == TokenType.TINSTANCEOF){
      lexer_pop(l);

      tmp : *Expression = ans;
      tmp.type = EType.varE;
      tmp.p1 = id;
      
      ans = malloc(sizeof Expression);
      ans.dbg = copy_debug_info(tn.dbg);
      ans.p2 = parse_type(l);
      ans.p1 = tmp;
      ans.type = EType.instanceE;
      return ans;
    } else if(tn.type == TokenType.TLPAR){ // function call
      lexer_pop(l);
      ans.p2 = parse_fcall_args(l);
      ans.p1 = id;
      ans.type = EType.fcallE;
      return ans;
    } else { // variable
      ans.type = EType.varE;
      ans.p1 = id;
      return ans;
    }
  } else if(tn.type == TokenType.TNUM) { // num
    ans.type = EType.cIntE;
    ans.p1 = tn.payload;
    return ans;
  } else if(tn.type == TokenType.TSTRV) { // string
    ans.type = EType.cStrE;
    ans.p1 = tn.payload;
    return ans;
  } else if(tn.type == TokenType.TSIZE){ // sizeof
    ans.type = EType.sizeE;
    // next is either a type or an id
    tmp := parse_type(l);
    ans.p1 = tmp;
    return ans;
  } else if(tn.type == TokenType.TCHAR){ // char
    ans.type = EType.cCharE;
    ans.p1 = tn.payload;
    return ans;
  } else {
    printf("Expected to see value, saw %d\n", tn.type);
    l.offset = l.count;
    printDBGandExit(tn.dbg);
    return 0;
  }

  return 0; // unreachable code
}

parse_expr_rec := (l: *Lexer, last: int) -> *Expression{
  ans : *Expression = parse_exp_val(l);
  // check op precedense
  prec := 0;
  opcode := 0;
  nt := lexer_peep(l);

  if(nt.type == TokenType.TEQEQ){
    prec = 1; // ==   
    opcode = OpCode.eq;
  }
  else if(nt.type == TokenType.TNEQ){
    prec = 1; // !=
    opcode = OpCode.neq;
  }
  else if(nt.type == TokenType.TLT){
    prec = 1; // <
    opcode = OpCode.lt;
  }
  else if(nt.type == TokenType.TLTE){
    prec = 1; // <=
    opcode = OpCode.lte;
  }
  else if(nt.type == TokenType.TGT){
    prec = 1; // >
    opcode = OpCode.gt;
  }
  else if(nt.type == TokenType.TGTE){
    prec = 1; // >=
    opcode = OpCode.gte;
  }
  else if(nt.type == TokenType.TPLUS){
    prec = 2; // +   
    opcode = OpCode.add;
  }
  else if(nt.type == TokenType.TDASH){
    prec = 2; // -   
    opcode = OpCode.minus;
  }
  else if(nt.type == TokenType.TSTAR){
    prec = 3; // *   
    opcode = OpCode.mult;
  }
  else if(nt.type == TokenType.TFSLASH){
    prec = 3; // /   
    opcode = OpCode.div;
  }
  else if(nt.type == TokenType.TPERC){
    prec = 3; // %   
    opcode = OpCode.rem;
  }

  if(prec){
    lexer_pop(l);
    expr1 := ans;
    expr2 : *Expression = parse_expr_rec(l, last);
    ans = malloc(sizeof Expression);
    ans.dbg = copy_debug_info(nt.dbg);

    ans.prec = prec;
    ans.type = EType.binE;
    ans.p1 = expr1;
    ans.p2 = opcode;
    ans.p3 = expr2;

    if(expr2.type == EType.binE){
      if(prec > expr2.prec){
        ans.prec = prec;
        return ans;
      }
      ans.p3 = expr2.p1;
      expr2.p1 = ans;
      return expr2;
    }
  }

  // It was a single value, return it
  return ans;
}

parse_expr := (l: *Lexer) -> *Expression{
  return parse_expr_rec(l, 0);
}

parse_statement := (l: *Lexer) -> *Statement{
  tn : *Token = lexer_pop(l);
  ans : *Statement = malloc(sizeof Statement);
  ans.dbg = copy_debug_info(tn.dbg);
  if(tn.type == TokenType.TRET){
    // Return
    tn : *Token = lexer_peep(l);
    if(tn.type == TokenType.TSEM){ // ;
      lexer_expect(l, TokenType.TSEM, ";");
      ans.type = SType.returnT;
      ans.p1 = 0;
      return ans;
    } else { // return expr ;
      ans.type = SType.returnT;
      ans.p1 = parse_expr(l);
      lexer_expect(l, TokenType.TSEM, ";");
      return ans;
    }
  } else if(tn.type == TokenType.TID){
    // var decl, var assign, function call, member_access, method_call
    ans.p1 = tn.payload;
    tn = lexer_pop(l);
    if(tn.type == TokenType.TCOL){ // : variable decl
      ans.type = SType.declT;
      ans.p2 = parse_type(l);
      // = or ;
      tn =  lexer_pop(l);
      if(tn.type == TokenType.TEQ){// assign
        ans.p3 = parse_expr(l);
        lexer_expect(l, TokenType.TSEM, ";");
        return ans;
      } else if(tn.type == TokenType.TSEM){// decl only
        // Nothing
        ans.p3 = 0;
        return ans;
      } else {
        printf("Expected to see = or ;, but saw %d instead", tn.type);
        l.offset = l.count;
        printDBGandExit(tn.dbg);
        return 0;
      }
    } else if(tn.type == TokenType.TDEF){ // := variable decl
      ans.type = SType.declT;
      ans.p2 = 0;
      ans.p3 = parse_expr(l);
      lexer_expect(l, TokenType.TSEM, ";");
      return ans;
    } else if(tn.type == TokenType.TEQ){ // = variable assign
      ans.type = SType.assignT;
      ans.p2 = parse_expr(l);
      lexer_expect(l, TokenType.TSEM, ";");
      return ans;
    } else if(tn.type == TokenType.TDOT){ // id.id = expr; 
      tmp : *Expression = malloc(sizeof Expression);
      tmp.dbg = copy_debug_info(tn.dbg);
      tmp.type = EType.varE;
      tmp.p1 = ans.p1;
      ans.p1 = tmp;
      while(tn.type == TokenType.TDOT){
        //
        tn = lexer_peep(l); // hack so I don't have to handle not seeing id
        lexer_expect(l, TokenType.TID, "id");
        tmp = malloc(sizeof Expression);
        tmp.dbg = copy_debug_info(tn.dbg);
        tmp.type = EType.memE;
        tmp.p1 = ans.p1;
        tmp.p2 = tn.payload;
        ans.p1 = tmp;
        ans.p2 = tn.payload;
        tn = lexer_peep(l);
        if(tn.type == TokenType.TDOT)
          lexer_pop(l);
      }
      // is it a method call or assignment?
      tn = lexer_peep(l);
      if(tn.type == TokenType.TLPAR){ // method call

        lexer_expect(l, TokenType.TLPAR, "(");

        lastExpr : *Expression = ans.p1;
        ans.p1 = lastExpr.p2;
        ans.p3 = lastExpr.p1;

        args : *Statement = malloc(sizeof Statement);
        args.dbg = copy_debug_info(tn.dbg);
        args.type = SType.argT;
        args.p1 = lastExpr.p1;
        // free(lastExpr); // TODO
        args.next = parse_fcall_args(l);

        lexer_expect(l, TokenType.TSEM, ";");

        ans.p2 = args;
        ans.type =  SType.methodCallT;
        return ans;
      } else { //assignment
        lexer_expect(l, TokenType.TEQ, "=");
        ans.p2 = parse_expr(l);
        lexer_expect(l, TokenType.TSEM, ";");
        ans.type = SType.memAssignT;
        return ans;
      }
    } else if(tn.type == TokenType.TLPAR){ // function call
      ans.p2 = parse_fcall_args(l);
      lexer_expect(l, TokenType.TSEM, ";");
      ans.type = SType.fcallT;
      return ans;
    } else {
      printf("Expected to see :, =, . (, but got %d\n", tn.type);
      l.offset = l.count;
      printDBGandExit(tn.dbg);
      return 0;
    }
  } else if(tn.type == TokenType.TIF){// if
    ans.type = SType.ifT;
    lexer_expect(l, TokenType.TLPAR, "(");
    ans.p1 = parse_expr(l);
    lexer_expect(l, TokenType.TRPAR, ")");

    ans.p2 = parse_statement(l);
    ans.p3 = 0;

    tn = lexer_peep(l);
    if(tn.type == TokenType.TELSE){ // else
      lexer_pop(l);
      ans.p3 = parse_statement(l);
    }
    return ans;
  } else if(tn.type == TokenType.TWHILE){
    // while
    ans.type = SType.whileT;
    lexer_expect(l, TokenType.TLPAR, "(");
    ans.p1 = parse_expr(l);
    lexer_expect(l, TokenType.TRPAR, ")");
    ans.p2 = parse_statement(l);
    return ans;
  } else if(tn.type == TokenType.TLCB){
    ans.type = SType.codeBlockT;
    prev : *Statement = 0;
    ans.p1 = 0;
    // {
    while((*lexer_peep(l)).type != TokenType.TRCB){
        tmp := parse_statement(l);
        if(ans.p1 == 0){
          ans.p1 = tmp;
        }
        if(prev)
          prev.next = tmp;
        prev = tmp;
    }
    lexer_expect(l, TokenType.TRCB, "}");
    return ans;
  } else if(tn.type == TokenType.TSTAR){ // pointer access variable assign
    ans.type = SType.ptrAssignT;
    ans.p1 = parse_expr(l);
    lexer_expect(l, TokenType.TEQ, "=");
    ans.p2 = parse_expr(l);
    lexer_expect(l, TokenType.TSEM, ";");
    return ans;
  } else {
    printf("Expected to see statement, saw %d\n", tn.type);
    l.offset = l.count;
    printDBGandExit(tn.dbg);
    return 0;
  }

  return 0; // unreachable code, here to prevent errors.
}

parse_function := (l: *Lexer) -> *Statement{
  // the function signature as well as opening { has been parsed

  ans : *Statement = malloc(sizeof Statement);
  {
    tn := lexer_peep(l);
    ans.dbg = copy_debug_info(tn.dbg);
  }
  ans.type = SType.funcDefT;
  ans.p3 = 0;

  // next token is not }
  prev : *Statement = 0;
  while((*lexer_peep(l)).type != TokenType.TRCB){
    tmp : *Statement = parse_statement(l);
    if(tmp)
      tmp.next = 0;
    if(ans.p3 == 0)
      ans.p3 = tmp;
    if(prev)
      prev.next = tmp;
    prev = tmp;
  }

  lexer_expect(l, TokenType.TRCB, "}");
  return ans;
}

parse_function_top := (l: *Lexer, args: *Type, ft: *FunctionType, prev: *Statement,id: string) -> *Statement {

      lexer_expect(l, TokenType.TLPAR, "(");

      // parse args
      while((*lexer_peep(l)).type != TokenType.TRPAR){
        tmp : *Statement = malloc(sizeof Statement);
        {
          tn := lexer_peep(l);
          tmp.dbg = copy_debug_info(tn.dbg);
        }
        tmp.p1 = (*(lexer_peep(l))).payload;
        lexer_expect(l, TokenType.TID, "id");
        lexer_expect(l, TokenType.TCOL, ":");

        if((*lexer_peep(l)).type == TokenType.T3DOT){
          lexer_expect(l, TokenType.T3DOT, "...");
          // TODO ensure it is the last argument
        }

        tmp.p2 = parse_type(l);
        tmp.p3 = 0;
        tmp.next = 0;
        tmp.type = SType.declT; // 1?

        if(ft.first == 0)
          ft.first = tmp;

        if(prev)
          prev.next = tmp;
        prev = tmp;

        if((*lexer_peep(l)).type == TokenType.TCOMMA)
          lexer_expect(l, TokenType.TCOMMA, ",");
        else if((*lexer_peep(l)).type != TokenType.TRPAR){
          printf("Expected to see ) or , \n");
          l.offset = l.count;
          printDBGandExit(tmp.dbg);
          return 0;
        }
      }


      lexer_expect(l, TokenType.TRPAR, ")");
      lexer_expect(l, TokenType.TARROW, "->");

      ft.returnType = parse_type(l);

      nt : *Token = lexer_pop(l);

      if(nt.type == TokenType.TSEM){
        // signature
        s : *Statement = malloc(sizeof Statement);
        s.dbg = copy_debug_info(nt.dbg);
        s.type = SType.funcSignT;
        s.p1 = id;
        s.p2 = args;
        return s;
      } else if(nt.type == TokenType.TLCB){
        // body
        s : *Statement = parse_function(l);
        s.p1 = id;
        s.p2 = args;
        return s;
      } else {
        printf("Expected to see ; or {, saw %d\n", nt.type);
        l.offset = l.count;
        printDBGandExit(nt.dbg);
        return 0;
      }
}

parse_top_level := (l: *Lexer) -> *Statement{
  if( (*lexer_peep(l)).type == TokenType.TID){
    test_tmp := lexer_peep(l);
    id : string = (*lexer_pop(l)).payload;

    // printf("Saw id %s \n", id);

    nt : *Token = lexer_pop(l);

    // id := () -> type { statements }
    // id := () -> type ;
    // id : struct { member define }
    // id.id := () -> type { statements }
    // id.id := () -> type ;
    if(nt.type == TokenType.TDEF){
       // function sign or function define

      args : *Type = malloc(sizeof Type);
      args.dbg = copy_debug_info(nt.dbg);
      args.type = TypeType.funcT;
      ft : *FunctionType = malloc(sizeof FunctionType);
      args.payload = ft;

      prev : * Statement = 0;
      ft.first = 0;

      return parse_function_top(l, args, ft, prev, id);

    } else if(nt.type == TokenType.TCOL){
      ans : *Statement = malloc(sizeof Statement);
      ans.type = SType.structDefT;
      ans.p1 = id;
      ans.p2 = 0;
      // is it interface?
      nt : *Token = lexer_peep(l);
      ans.dbg = copy_debug_info(nt.dbg);
      if(nt.type == TokenType.TINTERFACE){
        // it is an interface
        lexer_expect(l, TokenType.TINTERFACE, "interface");
        lexer_expect(l, TokenType.TLCB, "{");
        nt: *Token = lexer_peep(l);
        prev : *Statement = 0;
        while(nt.type != TokenType.TRCB){
          // parse methods
          tid := (*lexer_peep(l)).payload;
          lexer_expect(l, TokenType.TID, "id");
          lexer_expect(l, TokenType.TDEF, ":=");

          // augment *self*
          args : * Type = malloc(sizeof Type);
          args.dbg = copy_debug_info(nt.dbg);
          args.type = TypeType.funcT;
          ft : *FunctionType = malloc(sizeof FunctionType);
          args.payload = ft;

          atmpType : *Type = malloc(sizeof Type);
          atmpType.dbg = copy_debug_info(nt.dbg);
          atmpType.payload = id;
          atmpType.type = TypeType.namedT; // struct

          tmpType : *Type = malloc(sizeof Type);
          tmpType.dbg = copy_debug_info(nt.dbg);
          tmpType.payload = atmpType;
          tmpType.type = TypeType.pointerT; // pointer

          tmp_prev : *Statement = malloc(sizeof Statement);
          tmp_prev.dbg = copy_debug_info((*lexer_peep(l)).dbg);
          tmp_prev.p1 = "self";
          tmp_prev.p2 = tmpType;// type
          tmp_prev.p3 = 0;
          tmp_prev.next = 0;
          tmp_prev.type = SType.declT;

          ft.first = tmp_prev;

          tmp_m := parse_function_top(l, args, ft, tmp_prev, tid);

          if(prev)
            prev.next = tmp_m;
          if(ans.p2 == 0)
            ans.p2 = tmp_m;

          prev = tmp_m;
          prev.next = 0;

          nt = lexer_peep(l);
        }
        lexer_expect(l, TokenType.TRCB, "}");
        ans.type = SType.interfaceDefT;
        return ans;
      } else if(nt.type == TokenType.TENUM){ // enum
        lexer_expect(l, TokenType.TENUM, "enum");
        lexer_expect(l, TokenType.TLCB, "{");
        nt : *Token = lexer_peep(l);
        prev : *Statement = 0;
        last_value := 0;
        while(nt.type != TokenType.TRCB){
          tid := (*lexer_peep(l)).payload;
          lexer_expect(l, TokenType.TID, "id");
          nt = lexer_peep(l);
          if(nt.type == TokenType.TEQ){// we have an assigned value
            lexer_expect(l, TokenType.TEQ, "="); // TODO this is optional though...
            nt = lexer_peep(l);
            lexer_expect(l, TokenType.TNUM, "number");
            last_value = nt.payload;
          } else{// assign a value ourselves
            last_value = last_value + 1;
          }
          // TODO trailing comma is mandatory now, must be optional
          lexer_expect(l, TokenType.TCOMMA, ",");

          tmp : *Statement = malloc(sizeof Statement);
          tmp.dbg = copy_debug_info(nt.dbg);
          tmp.type = SType.enumMemT;
          tmp.p1 = tid;
          tmp.p2 = last_value;
          tmp.next = 0;

          if(prev)
            prev.next = tmp;
          if(!ans.p2)
            ans.p2 = tmp;
          prev = tmp;

          nt = lexer_peep(l);
        }
        lexer_expect(l, TokenType.TRCB, "}");

        ans.type = SType.enumDefT;
        return ans;
      } else {
        // struct
        lexer_expect(l, TokenType.TSTRUCT, "struct, interface or enum");
        lexer_expect(l, TokenType.TLCB, "{");
        nt: *Token = lexer_peep(l);
        prev : *Statement = 0;
        while(nt.type != TokenType.TRCB){
          tid := (*lexer_peep(l)).payload;
          lexer_expect(l, TokenType.TID, "id");
          lexer_expect(l, TokenType.TCOL, ":");
          tp := parse_type(l);
          lexer_expect(l, TokenType.TSEM, ";");
          nt = lexer_peep(l);

          tmp : *Statement = malloc(sizeof Statement);
          tmp.dbg = copy_debug_info(nt.dbg);
          tmp.type = SType.declT;
          tmp.p1 = tid;
          tmp.p2 = tp;
          tmp.next = 0;
          if(ans.p2 == 0)
            ans.p2 = tmp;
          if(prev)
            prev.next = tmp;
          prev = tmp;
        }
      lexer_pop(l); // }
      return ans;
      }
    } else if(nt.type == TokenType.TDOT) { // method define
      if( (*lexer_peep(l)).type != TokenType.TID){
        printf("Expected id, saw %d\n", (*lexer_peep(l)).type);
        printDBGandExit(nt.dbg);
      }
      method_name : string = (*lexer_pop(l)).payload;
      lexer_expect(l, TokenType.TDEF, ":=");

      args : * Type = malloc(sizeof Type);
      args.dbg = copy_debug_info(nt.dbg);
      args.type = TypeType.funcT;
      ft : *FunctionType = malloc(sizeof FunctionType);
      args.payload = ft;


      atmpType : *Type = malloc(sizeof Type);
      atmpType.dbg = copy_debug_info(nt.dbg);
      atmpType.payload = id;
      atmpType.type = TypeType.namedT; // struct

      tmpType : *Type = malloc(sizeof Type);
      tmpType.dbg = copy_debug_info(nt.dbg);
      tmpType.payload = atmpType;
      tmpType.type = TypeType.pointerT; // pointer

      tmp : *Statement = malloc(sizeof Statement);
      tmp.dbg = copy_debug_info((*lexer_peep(l)).dbg);
      tmp.p1 = "self";
      tmp.p2 = tmpType;
      tmp.p3 = 0;
      tmp.next = 0;
      tmp.type = SType.declT;

      ft.first = tmp;
      prev : *Statement = tmp;

      // id:= id$method_name
      id = strcat(id, strcat("$", method_name));

      return parse_function_top(l, args, ft, prev, id);

    } else {
      printf("Expected token : or :=, saw %d\n", nt.type);
      l.offset = l.count;
      printDBGandExit(nt.dbg);
      return 0;
    }
  } else if((*lexer_peep(l)).type == TokenType.TEOF){
    // end of file
    lexer_pop(l);
    return 0;

  } else {
    printf("Top level token, expect id saw %d\n", (*(l.ptr + l.offset)).type);
    l.offset = l.count;
    printDBGandExit((*(l.ptr+l.offset)).dbg);
    return 0;
  }

  return 0;
}

parser := (l: *Lexer) -> *Statement{
  l.offset = 0;

  ans : *Statement = 0;
  prev : *Statement = 0;
  while(1){
    if(l.offset == l.count)
       return ans;

    tmp := parse_top_level(l);
    if(tmp)
      tmp.next = 0;
    if(ans == 0)
      ans = tmp;
    if(prev)
      prev.next = tmp;
    prev = tmp;
  }

  return ans;
}

push_bb := (cc: *CC) -> void{
  bb : *BB = malloc(sizeof BB);
  bb.prev = cc.lastB;
  bb.names = 0;
  cc.lastB = bb;
  return;
}

pop_bb := (cc: *CC) -> void{
  bb := cc.lastB;
  cc.lastB = bb.prev;
  // TODO free?
  return;
}

cc_resolve_named := (cc: *CC, name: string) -> *Names{
  b := cc.lastB;
  while(b){
    n := b.names;
    while(n){
        if(streq(n.name, name)){
        return n;
        }
        n = n.next;
    }
    b = b.prev;
  }
  return 0;
}

cc_set_named := (cc: *CC, name: string, payload: *any) -> void {
  if(cc.lastB.names == 0){
    // just set it and be done
    cc.lastB.names = malloc(sizeof Names);
    cc.lastB.names.name = name;
    cc.lastB.names.payload = payload;
    cc.lastB.names.next = 0;
    return;
  }
  names := cc.lastB.names;
  while(1){
    // check for equal str
    if(streq(names.name, name)){
      names.payload = payload;
      return;
    }
    if(names.next == 0){
      names.next = malloc(sizeof Names);
      names.next.name = name;
      names.next.payload = payload;
      names.next.next = 0;
      return;
    }
    names = names.next;
  }
  return; // unreachable
}

typeresolve := (e: *Expression, cc: *CC) -> *Type{
  if(e.type == EType.varE){// variable
    n := cc_resolve_named(cc, e.p1);
    if(n == 0){
      printf("Variable %s not found\n", e.p1);
      printDBGandExit(e.dbg);
    }
    p : *VariablePayload = n.payload;
    if(p.alloc == 0){ // enum
      // TODO do I want to find another way for finding enums?
      t: *Type = malloc(sizeof Type);
      t.dbg = copy_debug_info(e.dbg);
      t.type = TypeType.enumT;
      t.payload = 0;
      return t;
    }
    return p.decl.p2;
  } else if(e.type == EType.memE){ // member access
    t := typeresolve(e.p1, cc);
    // verify that t is a struct
    while(t.type == TypeType.pointerT){ // pointer, go back
      t = t.payload;
    }
    if(t.type == TypeType.enumT){
      // it's enum
      t : *Type = malloc(sizeof Type);
      t.dbg = copy_debug_info(e.dbg);
      t.type = TypeType.intT;
      t.payload = 0;
      return t;
    }
    if(t.type != TypeType.namedT){
      printf("base of member should be a struct, but was %d\n", t.type);
      printDBGandExit(e.dbg);
    }
    s_name : string = t.payload;
    tmp := cc_resolve_named(cc, s_name);
    vp : *VariablePayload =  tmp.payload;
    f_mem :*Statement= vp.decl.p2;
    while(f_mem){
      if(streq(f_mem.p1, e.p2)){ // found the member
        return f_mem.p2;
      }
      f_mem = f_mem.next;
    }
    printf("Couldn't find member\n");
    printDBGandExit(e.dbg);
  } else if(e.type == EType.binE){ // binary expression
    // TODO
    if((e.p2 == OpCode.eq) + (e.p2 == OpCode.neq)
    + (e.p2 == OpCode.lt) + (e.p2 == OpCode.lte)
    + (e.p2 == OpCode.gt) + (e.p2 == OpCode.gte)){//bool
      t : *Type = malloc(sizeof Type);
      t.dbg = copy_debug_info(e.dbg);
      t.type = TypeType.boolT;
      t.payload = 0;
      return t;
    }
    return typeresolve(e.p1, cc); // return p1, whatever it is.
  } else if(e.type == EType.cIntE){ // const int
    t : *Type = malloc(sizeof Type);
    t.dbg = copy_debug_info(e.dbg);
    t.type = TypeType.intT;
    t.payload = 0;
    return t;
  } else if(e.type == EType.cCharE){ // const char
    t : *Type = malloc(sizeof Type);
    t.dbg = copy_debug_info(e.dbg);
    t.type = TypeType.uintT;
    t.payload = 8;
    return t;
  } else if(e.type == EType.cStrE){ // const string
    t : *Type = malloc(sizeof Type);
    t.dbg = copy_debug_info(e.dbg);
    t.type = TypeType.stringT;
    t.payload = 0;
    return t;
  } else if(e.type == EType.ptrE){ // pointer
    t : * Type = malloc(sizeof Type);
    t.dbg = copy_debug_info(e.dbg);
    t.type = TypeType.pointerT;
    t.payload = typeresolve(e.p1, cc);
    return t;
  } else if(e.type == EType.baseE){ // base
    t: * Type = typeresolve(e.p1, cc);
    // TODO ensure we are dealing with a pointer somewhere
    return t.payload;
  } else if(e.type == EType.fcallE){ // fcall type resolve
    n := cc_resolve_named(cc, e.p1);
    if(n == 0){
      printf("Unable to find function %s\n", e.p1);
      printDBGandExit(e.dbg);
    }
    p : *VariablePayload = n.payload;
    t : *Type = p.decl.p2;
    ft: *FunctionType = t.payload;
    return ft.returnType;
  } else if(e.type == EType.sizeE){
    t : *Type = malloc(sizeof Type);
    t.dbg = copy_debug_info(e.dbg);
    t.type = TypeType.intT;
    t.payload = 0;
    return t;
  } else if(e.type == EType.notE){ // not -> boolean
    t : *Type = malloc(sizeof Type);
    t.dbg = copy_debug_info(e.dbg);
    t.type = TypeType.boolT;
    t.payload = 0;
    return t;
  } else {
    printf("unknwon type resolve for expression type %d\n", e.type);
    printDBGandExit(e.dbg);
  }
  return 0;
}

typegen := (t: *Type, cc: *CC) -> *any{
  if(t.type == TypeType.namedT){// struct
    tmp :* Names = cc_resolve_named(cc, t.payload);
    if(tmp ==0){
      printf("Couldn't find type %s\n", t.payload);
      printDBGandExit(t.dbg);
    }
    vt : *VariablePayload = tmp.payload;
    if(vt.alloc == 0){
      // we have enum, return 64 int for now:
      return LLVMInt64TypeInContext(cc.context);
    }
    return vt.alloc;
  } else if((t.type == TypeType.uintT) + (t.type == TypeType.intT)){ // int
    if(t.payload == 0){
      return LLVMInt64TypeInContext(cc.context);
    } else if(t.payload == 8){
      return LLVMInt8TypeInContext(cc.context);
    } else if(t.payload == 16){
      return LLVMInt16TypeInContext(cc.context);
    } else if(t.payload == 32){
      return LLVMInt32TypeInContext(cc.context);
    } else if(t.payload == 64){
      return LLVMInt64TypeInContext(cc.context);
    } else {
      printf("unknown int type\n");
      printf("type = %d\n", t.payload);
      printDBGandExit(t.dbg);
    }
  } else if(t.type == TypeType.boolT){ // bool
    return LLVMInt1TypeInContext(cc.context);
  } else if(t.type == TypeType.stringT){ // string
    return LLVMPointerType(LLVMInt8TypeInContext(cc.context), 0);
  } else if(t.type == TypeType.pointerT){ // pointer
    base := typegen(t.payload, cc);
    return LLVMPointerType(base, 0);
  } else if(t.type == TypeType.voidT){ // void
    return LLVMVoidTypeInContext(cc.context);
  } else if(t.type == TypeType.anyT){ // any
    return LLVMPointerType(LLVMInt64TypeInContext(cc.context), 0);
  } else if(t.type == TypeType.funcT){
    // return compile_ftype_by_type(t.payload, cc);
    return LLVMPointerType(LLVMPointerType(LLVMInt64TypeInContext(cc.context), 0), 0);
  } else {
    printf("Unknown type in typegen %d\n", t.type);
    printDBGandExit(t.dbg);
  }
  return 0;
}

exprgen := (e: *Expression, cc: *CC) -> *any;
get_alloca := (e: *Expression, cc: *CC) -> *any;

exprgen_binop_icmp := (e: *Expression, cmpcode: int, cc: *CC) -> *any{

  lhs := exprgen(e.p1, cc);
  rhs := exprgen(e.p3, cc);

  ltt := typeresolve(e.p1, cc);
  rtt := typeresolve(e.p3, cc);

  sit := TypeType.intT; // signed int type
  uit := TypeType.uintT; // unsigned int type
  bit := TypeType.boolT;
  pt := TypeType.pointerT; // pointer type

  l_pt : bool = ltt.type == pt; // lhs is pointer
  r_pt : bool = rtt.type == pt;

  l_int := (ltt.type == sit)+ (ltt.type == uit) + (ltt.type == bit);
  r_int := (rtt.type == sit)+ (rtt.type == uit) + (rtt.type == bit);

  // TODO check type
  // TODO handle float properly
  if(l_pt != r_pt){
    if(l_pt){
      rhs = LLVMBuildIntToPtr(cc.builder, rhs, LLVMTypeOf(lhs), "rhs");
    } else {
      lhs = LLVMBuildIntToPtr(cc.builder, lhs, LLVMTypeOf(rhs), "lhs");
    }
  } else if((LLVMTypeOf(lhs) == LLVMTypeOf(rhs))){} else { // TODO we need a !=
    if(l_int){
      rhs = LLVMBuildIntCast2(cc.builder, rhs, LLVMTypeOf(lhs), rtt.type == sit, "rhs");
    } else {
      printf("unimplemented icmp exprgen\n");
      printDBGandExit(e.dbg);
    }
  }
  return LLVMBuildICmp(cc.builder, cmpcode, lhs, rhs, "cmp");
}

exprgen_binop := (e: *Expression, cc: *CC) -> *any{
  // TODO reimplement this, it's terrible.
  op := e.p2;
  if(op == OpCode.eq){
    return exprgen_binop_icmp(e, 32, cc);
  }

  if(op == OpCode.neq){
    return exprgen_binop_icmp(e, 33, cc);
  }

  lhs := exprgen(e.p1, cc);
  rhs := exprgen(e.p3, cc);

  ltt := typeresolve(e.p1, cc);
  rtt := typeresolve(e.p3, cc);

  sit := TypeType.intT; // signed int type
  uit := TypeType.uintT; // unsigned int type
  bit := TypeType.boolT;
  ft := TypeType.floatT; // float type
  pt := TypeType.pointerT; // pointer type

  l_pt : bool = ltt.type == pt; // lhs is pointer
  r_pt : bool = rtt.type == pt;

  l_int := (ltt.type == sit)+ (ltt.type == uit) + (ltt.type == bit);
  r_int := (rtt.type == sit)+ (rtt.type == uit) + (rtt.type == bit);

  // TODO refine this
  is_unsigned := (ltt.type == uit) + (rtt.type == uit);

  if(op == OpCode.lt){// <
    if(is_unsigned)
      return exprgen_binop_icmp(e, 36, cc);
    return exprgen_binop_icmp(e, 40, cc);
  }
  if(op == OpCode.lte){// <=
    if(is_unsigned)
      return exprgen_binop_icmp(e, 37, cc);
    return exprgen_binop_icmp(e, 41, cc);
  }
  if(op == OpCode.gt){// >
    if(is_unsigned)
      return exprgen_binop_icmp(e, 34, cc);
    return exprgen_binop_icmp(e, 38, cc);
  }
  if(op == OpCode.gte){// >=
    if(is_unsigned)
      return exprgen_binop_icmp(e, 35, cc);
    return exprgen_binop_icmp(e, 39, cc);
  }

  // TODO reimplement this, it's terrible.

  tmp : bool = l_pt + r_pt;
  // TODO this is a bug and needs to be fixed, l_pt + r_pt == 0 was becoming false
  if(tmp == 0){ // regular arithmetic
    tmp : bool = LLVMTypeOf(lhs) == LLVMTypeOf(rhs);
    if(tmp == 0){ // TODO we need a !=
      // convert
      if(r_int * l_int){
        // TODO cast the smaller one to bigger one
        rhs = LLVMBuildIntCast2(cc.builder, rhs, LLVMTypeOf(lhs), rtt.type == sit, "rhs");
      } else if(ltt.type == rtt.type){
        if(l_int){
          // TODO cast the smaller one to bigger one
          rhs = LLVMBuildIntCast2(cc.builder, rhs, LLVMTypeOf(lhs), rtt.type == sit, "rhs");
        } else {
          // TODO float point, not doing now since we don't have floats yet
          printf("Unimplemented in binop nested if\n");
          printDBGandExit(e.dbg);
        }
      } else if(l_int){
        // TODO rhs is float
        printf("Unimplemented in binop else if\n");
        printDBGandExit(e.dbg);
      } else {
        // TODO lhs is float
        printf("Unimplemented in binop else\n");
        printDBGandExit(e.dbg);
      }
    }
    inst : int;
    // TODO handle fp
    if(op == OpCode.add){ // +
      inst = 8;
    } else if(op == OpCode.minus){ // -
      inst = 10;
    } else if(op == OpCode.mult){ // *
      inst = 12;
    } else if(op == OpCode.div){ // /
      // TODO handle other cases
      inst = 15;
      if((ltt.type == uit) * (rtt.type == uit)){// both are unsigned
        inst = 14;
      }
    } else if(op == OpCode.rem){ // %
      // TODO handle other cases
      inst = 18;
      if((ltt.type == uit) * (rtt.type == uit)){// both are unsigned
        inst = 17;
      }
    } else {
      printf("Unknown op %d\n", op);
      printDBGandExit(e.dbg);
    }
    return LLVMBuildBinOp(cc.builder, inst, lhs, rhs, "binop");
  } else { // handle pointer arithmetic 
    if((ltt.type != pt) * (rtt.type == pt)){
      printf("unsupported binary operation %d %d %d\n", ltt.type, op, rtt.type);
      printDBGandExit(e.dbg);
    }
    // lhs must be the pointer:
    if((ltt.type != pt) * (rtt.type == pt)){
      tmp := lhs;
      lhs = rhs;
      rhs = tmp;
    }

    t := LLVMTypeOf(lhs);
    if(LLVMGetTypeKind(t) == 12){
      t = LLVMGetElementType(t);
    } else {
      t = LLVMTypeOf(rhs);
      t = LLVMGetElementType(t);
      tmp := lhs;
      lhs = rhs;
      rhs = lhs;
    }


    if(op == OpCode.minus){// -
      mone := LLVMConstInt(LLVMInt64TypeInContext(cc.context), 0-1, 1);
      rhs = LLVMBuildBinOp(cc.builder, 12, rhs, mone, "ptrop"); // TODO problem?
    }

    indices := malloc(sizeof *any);

    *indices = rhs;
    return LLVMBuildInBoundsGEP2(cc.builder, t, lhs, indices, 1, "ptrarrptr");
  }

  printf("unknown binary operation %d %d %d\n", ltt.type, op, rtt.type);
  printDBGandExit(e.dbg);
  return 0;
}

compile_ftype_by_type := (ft: *FunctionType, cc: *CC) -> *any{
  args_count := 0;
  {
    tmp : *Statement = ft.first;
    while(tmp){
      args_count = args_count + 1;
      tmp = tmp.next;
    }
  }
  args := malloc(args_count * sizeof *any);
  arg : *Statement = ft.first;
  count := 0;
  while(arg){
    // gen type
    *(args + count) = typegen(arg.p2, cc);
    count = count + 1;
    arg = arg.next;
  }

  // TODO handle varargs
  return LLVMFunctionType(typegen(ft.returnType, cc), args, args_count, 0);
}

compile_ftype := (s: *Statement, cc: *CC) -> *any{
  // count number of args
  t : *Type = s.p2;
  ft : *FunctionType = t.payload;
  return compile_ftype_by_type(ft, cc);
}

fcall_util := (e: *Expression, cc: *CC, calleeF: *any) -> *any {
  count := 0;
  arg : *Statement = e.p2;
  while(arg){
    arg = arg.next;
    count = count + 1;
  }

  args := malloc(count * sizeof *any);

  arg = e.p2;
  count = 0;
  while(arg){
    // TODO possible casts here
    *(args + count) = exprgen(arg.p1, cc);
    arg = arg.next;
    count = count + 1;
  }
  name := "retval";
  return LLVMBuildCall(cc.builder, calleeF, args, count, name);
}

resolve_fp := (e: *Expression, cc: *CC) -> *any{
  name := cc_resolve_named(cc, e.p1);
  if(name == 0){
    return 0;
  }
  vp : *VariablePayload = name.payload;
  alloc := vp.alloc;

  // cast
  f : *FunctionType= malloc(sizeof FunctionType);

  f.first = 0; // TODO
  anyt : *Type = malloc(sizeof Type);
  anyt.dbg = copy_debug_info(e.dbg);
  anyt.type = TypeType.anyT;
  anyt.payload = 0;
  f.returnType = anyt; // TODO

  ftype := compile_ftype_by_type(f, cc);
  alloc = LLVMBuildIntToPtr(cc.builder, alloc, LLVMPointerType(LLVMPointerType(ftype, 0), 0), "fptr");
  return LLVMBuildLoad(cc.builder, alloc, e.p1);
}

exprgen_fcall := (e: *Expression, cc: *CC)-> *any{
  // p1 id
  // p2 args
  calleeF := LLVMGetNamedFunction(cc.module, e.p1);

  if(!calleeF){// Maybe it's a function ptr
    calleeF = resolve_fp(e, cc);
  }

  if(calleeF == 0){
    printf("Function not found %s\n", e.p1);
    printDBGandExit(e.dbg);
  }

  return fcall_util(e, cc, calleeF);
}

exprgen_methodcall := (e: *Expression, cc: *CC) -> *any{
  tmpE : *Expression = malloc(sizeof Expression);
  tmpE.dbg = copy_debug_info(e.dbg);
  tmpE.type = EType.fcallE;


  classBase := typeresolve(e.p3, cc);
  if(classBase == 0){
    printf("Couldn't find the base class for method call\n");
    printDBGandExit(e.dbg);
  }

  // resolve pointer
  if(classBase.type == TypeType.pointerT){
    classBase = classBase.payload;
    // it's a pointer, all is well, just resolve base
  } else {
    // it's not a pointer, create a pointer to it
    tmp : *Statement = e.p2;

    baseE : *Statement = malloc(sizeof Statement);
    baseE.dbg = copy_debug_info(e.dbg);

    eBase : *Expression = malloc(sizeof Expression);
    eBase.dbg = copy_debug_info(e.dbg);
    eBase.type = EType.baseE; // base of
    eBase.p1 = tmp.p1;

    baseE.type = SType.argT;
    baseE.p1 = eBase;
    baseE.next = tmp.next;

    e.p2 = baseE;
  }

  tmpE.p2 = e.p2;

  if(classBase.type != TypeType.namedT){
    printf("Tried to call method on type %d\n", classBase.type);
    printf("Can't call methods on non-structs\n");
    printDBGandExit(e.dbg);
  }

  className := classBase.payload;


  // struct or interface?
  // let's see if className$$ exists in context
  tmp_named := cc_resolve_named(cc, strcat(className, "$$"));
  if(tmp_named){
    itVP : *VariablePayload = tmp_named.payload;
    // interface
    // find the index
    it : *Statement = itVP.decl;
    ind := 1; // it starts from 1
    f : *Statement = it.p2;
    while(f){
      if(streq(e.p1, f.p1)){
        tmp_named = cc_resolve_named(cc, className);
        itfpsVP : *VariablePayload = tmp_named.payload;
        // found it
        // find base
        itbase := get_alloca(e.p3, cc);

        base := LLVMBuildStructGEP2(cc.builder, itfpsVP.alloc, itbase, 1, "baseptr");
        // find function pointer
        calleeF := LLVMBuildStructGEP2(cc.builder, itVP.alloc, LLVMBuildLoad(cc.builder, base, "base_fptr"), ind, "fptr");
        calleeF = LLVMBuildIntToPtr(cc.builder, calleeF, LLVMPointerType(LLVMPointerType(compile_ftype(f, cc), 0), 0), "fptr");
        calleeF = LLVMBuildLoad(cc.builder, calleeF, "fptr");

        tmp : *Statement = tmpE.p2;

        be : *Statement = malloc(sizeof Statement);
        be.dbg = copy_debug_info(e.dbg);
        be.type = SType.argT;
        be.next = tmp.next;

        eBase : *Expression = malloc(sizeof Expression);
        eBase.dbg = copy_debug_info(e.dbg);
        eBase.type = EType.ptrE; // pointer
        eBase.p1 = tmp.p1;

        be.p1 = eBase;

        tmpE.p2 = be;

        return fcall_util(tmpE, cc, calleeF);
      }
      ind = ind + 1;
      f = f.next;
    }
    // Interface doesn't have that method on it's own, maybe it's user defined, continue
  }


  tmpE.p1 = strcat(className, strcat("$", e.p1)); // type(e.p3) + "$" + e.p1


  return exprgen_fcall(tmpE, cc);
}

get_alloca := (e: *Expression, cc: *CC) -> *any{
  if(e.type == EType.varE){// variable
    name := cc_resolve_named(cc, e.p1);
    if(name == 0){
      printf("Variable not found %s\n", e.p1);
    }
    vp : *VariablePayload = name.payload;
    return vp.alloc;
  } else if(e.type == EType.memE){//member
    member_ind := 0;
    tmpe := typeresolve(e.p1, cc);
    level := 0;
    p := tmpe;
    while(p.type == TypeType.pointerT){ // go til you reach the base
      level = level + 1;
      p = p.payload;
    }

    alloc := get_alloca(e.p1, cc);
    // TODO, what is happeninig here?
    if(level == 1){
      alloc = LLVMBuildLoad(cc.builder, alloc, "paccess");
      level = level - 1;
    } else if(level == 3){
      alloc = LLVMBuildLoad(cc.builder, alloc, "paccess");
    }
    // get the struct
    // p.payload is the struct name
    s_name : string = p.payload;
    tmp := cc_resolve_named(cc, s_name);
    vp : *VariablePayload =  tmp.payload;
    f_mem :*Statement= vp.decl.p2;
    st := vp.alloc;
    while(f_mem){
      if(streq(f_mem.p1, e.p2)){ // found the member

        // TODO can I delete these???
        indices := malloc(2*sizeof *any);
        *(indices) = LLVMConstInt(LLVMInt64TypeInContext(cc.context), 0, 0);
        *(indices + 1) = LLVMConstInt(LLVMInt64TypeInContext(cc.context), member_ind, 0);

        ans := LLVMBuildStructGEP2(cc.builder, st, alloc, member_ind, "memberptr");

        return ans;
      }
      f_mem = f_mem.next;
      member_ind = member_ind + 1;
    }
    printf("Couldn't find member %s\n", e.p2);
    printDBGandExit(e.dbg);
  } else if(e.type == EType.binE){// binop
    tmp := exprgen(e, cc);
    tmp = LLVMBuildLoad(cc.builder, tmp, "binopload");
    return tmp;
  } else if(e.type == EType.ptrE){//ptr
    tmp := exprgen(e.p1, cc);
    return tmp;
  }
  printf("Unknown expression in alloca %d\n", e.type);
  printDBGandExit(e.dbg);
  return 0;
}

exprgen_pointer := (e: *Expression, cc: *CC) -> *any{
  return LLVMBuildLoad(cc.builder, exprgen(e.p1, cc), "ptra");
}

typesize := (e: *Type, cc: *CC) -> int{
  t := typegen(e, cc);
  td := LLVMGetModuleDataLayout(cc.module);
  size := LLVMSizeOfTypeInBits(td, t);
  return size / 8;
}

exprgen_sizeof := (e: *Expression, cc: *CC) -> *any{
  size := typesize(e.p1, cc);
  return LLVMConstInt(LLVMInt32TypeInContext(cc.context), size, 0);
}

exprgen_not := (e: *Expression, cc: *CC) -> *any{
  val := exprgen(e.p1, cc);
  correct_type : bool = LLVMTypeOf(val) == LLVMInt64TypeInContext(cc.context);
  if(correct_type == 0){
    val = LLVMBuildIntCast2(cc.builder, val, LLVMInt64TypeInContext(cc.context), 1, "castnot");
  }
  return LLVMBuildICmp(cc.builder, 32, val, LLVMConstInt(LLVMInt64TypeInContext(cc.context), 0, 0), "not");
}

resolve_interface := (e: *Expression, cc: *CC) -> *Statement {
  // return pointer to interface statement or null
  st := typeresolve(e, cc);
  while(st.type == TypeType.pointerT){
    st = st.payload;
  }
  if(st.type == TypeType.namedT){
    // might be a struct or interface
    c_name := cc_resolve_named(cc, strcat(st.payload, "$$"));
    if(c_name){
      vp : *VariablePayload = c_name.payload;
      return vp.decl;
    }
  }
  return 0;
}

compile_struct_to_interface := (it: *Statement, st: *Statement, cc: *CC) -> *any {
  // Create the VPTR and other necessary structures
  cc_name := strcat(st.p1, strcat("#", it.p1));

  // the vptr type is...
  cc_named := cc_resolve_named(cc, strcat(it.p1, "$$"));
  if(!cc_named){
    printf("Error in struct to interface, unknown interface scheme $s\n", it.p1);
    printDBGandExit(it.dbg);
  }
  cc_named_vp : *VariablePayload = cc_named.payload;
  vptr_t := cc_named_vp.alloc;

  // we need to create const array
  vptr_ref := LLVMAddGlobal(cc.module, vptr_t, cc_name);

  // create vptr
  count := 1; // self
  f : *Statement = it.p2;
  while(f){
    count = count + 1;
    f = f.next;
  }

  vals := malloc(sizeof *any * count);
  f = it.p2;

  *vals = LLVMConstInt(LLVMInt64TypeInContext(cc.context), st.p3, 0); // struct num

  i := 1;
  while(f){
    // find the function!
    method_name := f.p1;
    tmp_f := LLVMGetNamedFunction(cc.module, strcat(st.p1, strcat("$", method_name)));

    if(!tmp_f){
      printf("Couldn't find method %s on struct %s needed for interface %s\n", method_name, st.p1, it.p1);
      printDBGandExit(st.dbg);
    }

    *(vals + i) = LLVMConstBitCast(tmp_f, LLVMPointerType(LLVMInt64TypeInContext(cc.context), 0));
    // tmp_f // TODO remove
    f = f.next;
    i = i + 1;
  }

  vptr := LLVMConstNamedStruct(vptr_t, vals, count);

  // set const
  LLVMSetInitializer(vptr_ref, vptr);
  LLVMSetGlobalConstant(vptr_ref, 1);

  return vptr_ref;
}


exprgen_instance := (e: *Expression, cc: *CC) -> *any{
  // TODO
  // ensure lhs is interface variable
  it := resolve_interface(e.p1, cc);
  if(!it){
    printf("LHS of instance must be variable of interface\n");
    printDBGandExit(e.dbg);
  }
  cc_named := cc_resolve_named(cc, it.p1);
  if(!cc_named){
    printf("Error in struct to interface cast, unknown interface scheme %s\n", it.p1);
    printDBGandExit(e.dbg);
  }
  cc_named_vp : *VariablePayload = cc_named.payload;
  tp := cc_named_vp.alloc;


  cc_named := cc_resolve_named(cc, strcat(it.p1, "$$"));
  if(!cc_named){
    printf("Error in struct to interface, unknown interface scheme $s\n", it.p1);
    printDBGandExit(e.dbg);
  }
  cc_named_vp : *VariablePayload = cc_named.payload;
  tpp := cc_named_vp.alloc;

  // ensure rhs is struct
  t : *Type = e.p2;
  if(t.type != TypeType.namedT){
    printf("RHS of instance of must be a struct\n");
    printDBGandExit(e.dbg);
  }
  s_name := t.payload;
  c_name:= cc_resolve_named(cc, strcat(s_name, "$$"));
  if(c_name){
    // interface
    printf("RHS of instance of must be a struct\n");
    printDBGandExit(e.dbg);
  }

  c_name = cc_resolve_named(cc, s_name);
  if(!c_name){
    printf("Couldn't find struct %s\n", s_name);
    printDBGandExit(e.dbg);
  }
  vp: *VariablePayload = c_name.payload;
  if(vp.alloc == 0){
    // enum
    printf("RHS of instance of must be a struct\n");
    printDBGandExit(e.dbg);
  }

  // TODO it might be a variable, fix that!!!!!

  // we are ok, it's a struct
  st : *Statement = vp.decl;

  // resolve vptr
  cc_name := strcat(st.p1, strcat("#", it.p1));
  vptr := LLVMGetNamedGlobal(cc.module, cc_name);

  // ensure they are compatible
  if(!vptr)
    vptr = compile_struct_to_interface(it, st, cc);

  // compare lhs -> vptr to rhs's vptr
  lhs := get_alloca(e.p1, cc);
  
  vptr_ptr := LLVMBuildStructGEP2(cc.builder, tp, lhs, 1, "vptrptr");
  vptr_ptr = LLVMBuildLoad(cc.builder, vptr_ptr, "vptr_val");

  vptr_ptr = LLVMBuildStructGEP2(cc.builder, tpp, vptr_ptr, 0, "basevptr_ptr");

  vptr_ptr = LLVMBuildLoad(cc.builder, vptr_ptr, "bvptr_val");
  vptr := LLVMConstInt(LLVMInt64TypeInContext(cc.context), st.p3, 0);

  return LLVMBuildICmp(cc.builder, 32, vptr_ptr, vptr, "instance");
}

exprgen_base := (e: *Expression, cc: *CC) -> * any{
  return get_alloca(e.p1, cc);
}

exprgen_enum_member := (e: *Expression, en: *Statement, cc: *CC) -> *any{
  member: *Statement = en.p2;
  while(member){
    if(streq(e.p2, member.p1)){
      // found it
      // TODO maybe different types?
      return LLVMConstInt(LLVMInt64TypeInContext(cc.context), member.p2,1);
    }
    member = member.next;
  }
  printf("Enum %s doesn't have member %s\n", en.p1, e.p2);
  printDBGandExit(e.dbg);
  return 0;
}

resolve_enum := (e: *Expression, cc: *CC) -> *Statement {
  // return pointer to struct statement or null
  t := typeresolve(e.p1, cc);
  if(t.type == TypeType.enumT){ // should it be 15? TODO
    // it's enum
    tmpE : *Expression = e.p1;
    c_name := cc_resolve_named(cc, tmpE.p1);
    vp : *VariablePayload = c_name.payload;
    if(vp.alloc == 0)
      return vp.decl;
  }
  return 0;
}

exprgen := (e: *Expression, cc: *CC) -> *any{
  if(e.type == EType.varE){// variable
    name := cc_resolve_named(cc, e.p1);
    if(name == 0){
      printf("Variable not found %s\n", e.p1);
    }
    vp : *VariablePayload = name.payload;
    return LLVMBuildLoad(cc.builder, vp.alloc, e.p1);
  } else if(e.type == EType.memE){// member access
    // Are we dealing with struct or enum?
    en := resolve_enum(e, cc);
    if(en){
      return exprgen_enum_member(e, en, cc);
    }
    alloc := get_alloca(e, cc);
    return LLVMBuildLoad(cc.builder, alloc, "memberptr");
  } else if(e.type == EType.binE){// binary operation
    return exprgen_binop(e, cc);
  } else if(e.type == EType.cIntE){// const int
    // TODO refine int choice based on arch
    // TODO refine unsigned choice
    return LLVMConstInt(LLVMInt64TypeInContext(cc.context), e.p1, 1);
  }  else if(e.type == EType.cCharE){// const char
    return LLVMConstInt(LLVMInt8TypeInContext(cc.context), e.p1, 0);
  } else if(e.type == EType.cStrE){// const string
    return LLVMBuildGlobalStringPtr(cc.builder, e.p1, "gstr");
  } else if(e.type == EType.ptrE){// pointer
    return exprgen_pointer(e, cc);
  } else if(e.type == EType.fcallE){// fcall
    return exprgen_fcall(e, cc);
  } else if(e.type == EType.sizeE){// sizeof
    return exprgen_sizeof(e, cc);
  } else if(e.type == EType.notE){ // not
    return exprgen_not(e, cc);
  } else if(e.type == EType.methodCallE){ // methodcall
    return exprgen_methodcall(e, cc);
  } else if(e.type == EType.baseE){ // base (reverse pointer)
    return exprgen_base(e, cc);
  } else if(e.type == EType.instanceE){
    return exprgen_instance(e, cc);
  } else {
    printf("Unknown expression in exprgen %d\n", e.type);
    printDBGandExit(e.dbg);
  }
  return 0;
}

compile := (s: *Statement, cc: *CC)->void;

compile_fs := (s: *Statement, cc: *CC) -> *any{
  if(LLVMGetNamedFunction(cc.module, s.p1)){
    // Overwriting existing function
    return LLVMGetNamedFunction(cc.module, s.p1);
  }
  ftype := compile_ftype(s, cc);
  f := LLVMAddFunction(cc.module, s.p1, ftype);

  payload: *VariablePayload = malloc(sizeof VariablePayload);
  payload.alloc = f;
  payload.decl = s;
  cc_set_named(cc, s.p1, payload);

  return f;
}

compile_function := (s: *Statement, cc: *CC) -> void {
  f := compile_fs(s, cc);

  bblock := LLVMAppendBasicBlockInContext(cc.context, f, "entry");
  LLVMPositionBuilder(cc.builder, bblock, 0);

  // push block
  push_bb(cc);

  // set param name
  t : *Type = s.p2;
  ft: *FunctionType = t.payload;
  arg : *Statement = ft.first;
  count := 0;
  while(arg){
    param := LLVMGetParam(f, count);
    LLVMSetValueName2(param, arg.p1, strlen(arg.p1));
    alloc := LLVMBuildAlloca(cc.builder, typegen(arg.p2, cc), arg.p1);
    // set variable name
    payload: *VariablePayload = malloc(sizeof VariablePayload);
    payload.alloc = alloc;
    payload.decl = arg;
    cc_set_named(cc, arg.p1, payload);
    LLVMBuildStore(cc.builder, param, alloc);
    count = count + 1;
    arg = arg.next;
  }
  // generate the body
  stmt : *Statement = s.p3;
  if(stmt)
    compile(stmt, cc);

  pop_bb(cc);
  return;
}
compile_struct := (s: *Statement, cc: *CC) -> void{
  cc.structNum = cc.structNum + 1;
  s.p3 = cc.structNum;

  st := LLVMStructCreateNamed(cc.context, s.p1);
  vp : *VariablePayload = malloc(sizeof VariablePayload);
  vp.alloc = st;
  vp.decl = s;
  cc_set_named(cc, s.p1, vp);
  count := 0;
  f : *Statement = s.p2;
  while(f){
    count = count + 1;
    f = f.next;
  }
  members : *any = malloc(sizeof *any * count);
  f = s.p2;
  i := 0;
  while(f){
    *(members + i) = typegen(f.p2, cc);
    f = f.next;
    i = i + 1;
  }
  LLVMStructSetBody(st, members, count, 0); // TODO changed packed?

  return;
}

compile_interface := (s: *Statement, cc: *CC) -> void {
  // we need TWO interfaces
  name_w_dollar_sign := strcat(s.p1, "$$");

  // This is the interface function pointer structure ;; stored as name$$
  it := LLVMStructCreateNamed(cc.context, name_w_dollar_sign); 
  vp : *VariablePayload = malloc(sizeof VariablePayload);
  vp.alloc = it;
  vp.decl = s;
  cc_set_named(cc, name_w_dollar_sign, vp);

  count := 1; // we have one ref to orignial class
  f : *Statement = s.p2;
  while(f){
    count = count + 1;
    f = f.next;
  }
  members : *any = malloc(sizeof *any * count);
  f = s.p2;

  pointer_type := LLVMPointerType(LLVMInt64TypeInContext(cc.context), 0);

  *members = LLVMInt64TypeInContext(cc.context);
  i := 1;
  while(f){
    *(members + i) = pointer_type;
    f = f.next;
    i = i + 1;
  }
  LLVMStructSetBody(it, members, count, 0); // TODO change packed?

  // This is the interface holdre structure ;; stored as name
  ith := LLVMStructCreateNamed(cc.context, s.p1);

  vph : *VariablePayload = malloc(sizeof VariablePayload);
  vph.alloc = ith;
  vph.decl = s;
  cc_set_named(cc, s.p1, vph);

  members_2 : *any = malloc(sizeof *any * 2); // self, fps
  *members_2 = pointer_type;
  *(members_2 + 1) = LLVMPointerType(it, 0);

  LLVMStructSetBody(ith, members_2, 2, 0); // TODO change packed?

  return;
}

is_br_ok := (cc: *CC) -> bool{
  instr := LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(cc.builder));
  if(instr == 0){ // if there aren't any instruction, it's okay
    return 1;
  }
  opcode := LLVMGetInstructionOpcode(instr);
  if(opcode == 0){// ret
    return 0;
  }
  if(opcode == 1){// br
    return 0;
  }
  return 1;
}

compile_if := (s: *Statement, cc: *CC) -> void{
  f := LLVMGetBasicBlockParent(LLVMGetInsertBlock(cc.builder));

  ifB := LLVMAppendBasicBlockInContext(cc.context, f, "if");
  elseB :*any;
  mergeB := LLVMCreateBasicBlockInContext(cc.context, "ifcont");
  if(s.p3){
    elseB = LLVMCreateBasicBlockInContext(cc.context, "else");
  }
  else{
    elseB = mergeB;
  }
  cond := exprgen(s.p1, cc);

  correct_type : bool = LLVMTypeOf(cond) == LLVMInt64TypeInContext(cc.context);
  if(correct_type == 0){
    cond = LLVMBuildIntCast2(cc.builder, cond, LLVMInt64TypeInContext(cc.context), 1, "cond");
  }

  cond = LLVMBuildICmp(cc.builder, 33, cond, LLVMConstInt(LLVMInt64TypeInContext(cc.context), 0, 0), "ifcond");

  LLVMBuildCondBr(cc.builder, cond, ifB, elseB);

  push_bb(cc);
  LLVMPositionBuilder(cc.builder, ifB, 0);
  compile(s.p2, cc);
  if(is_br_ok(cc)){
    LLVMBuildBr(cc.builder, mergeB);
  }
  pop_bb(cc);

  if(s.p3){
    push_bb(cc);
    LLVMAppendExistingBasicBlock(f, elseB);
    LLVMPositionBuilder(cc.builder, elseB, 0);
    compile(s.p3, cc);
    if(is_br_ok(cc)){
        LLVMBuildBr(cc.builder, mergeB);
    }
    pop_bb(cc);
  }

  LLVMAppendExistingBasicBlock(f, mergeB);
  LLVMPositionBuilder(cc.builder, mergeB, 0);

  return 0;
}

compile_while := (s: *Statement, cc: *CC) -> void{
  f := LLVMGetBasicBlockParent(LLVMGetInsertBlock(cc.builder));

  condB := LLVMAppendBasicBlockInContext(cc.context, f, "whilecond");
  whileB := LLVMAppendBasicBlockInContext(cc.context, f, "while");
  mergeB := LLVMCreateBasicBlockInContext(cc.context, "whilecont");

  LLVMBuildBr(cc.builder, condB);
  LLVMPositionBuilder(cc.builder, condB, 0);

  cond := exprgen(s.p1, cc);

  correct_type : bool = LLVMTypeOf(cond) == LLVMInt64TypeInContext(cc.context);
  if(correct_type == 0){
    cond = LLVMBuildIntCast2(cc.builder, cond, LLVMInt64TypeInContext(cc.context), 1, "cond");
  }

  cond = LLVMBuildICmp(cc.builder, 33, cond, LLVMConstInt(LLVMInt64TypeInContext(cc.context), 0, 0), "whilecond");

  LLVMBuildCondBr(cc.builder, cond, whileB, mergeB);

  push_bb(cc);
  LLVMPositionBuilder(cc.builder, whileB, 0);
  compile(s.p2, cc);
  if(is_br_ok(cc)){
    LLVMBuildBr(cc.builder, condB);
  }
  pop_bb(cc);

  LLVMAppendExistingBasicBlock(f, mergeB);
  LLVMPositionBuilder(cc.builder, mergeB, 0);

  return 0;
}

compile_ret := (s: *Statement, cc: *CC) -> void{
  if(s.p1){// has value
    LLVMBuildRet(cc.builder, exprgen(s.p1, cc));
  } else {
    LLVMBuildRetVoid(cc.builder);
  }
  return ;
}

struct_to_interface_cast := (it: *Statement, st: *Statement, alloc: *any, val: *any, cc: *CC) -> void {
  /**
  * alloc is an alloca and val is a direct pointer
  */
  cc_name := strcat(st.p1, strcat("#", it.p1));

  // try to find vptr
  vptr := LLVMGetNamedGlobal(cc.module, cc_name);

  // if not found, create it
  if(!vptr)
    vptr = compile_struct_to_interface(it, st, cc);

  // assing shell's values

  // assing self -> 1

  // the vptr type is...
  cc_named := cc_resolve_named(cc, it.p1);
  if(!cc_named){
    printf("Error in struct to interface cast, unknown interface scheme %s\n", it.p1);
    printDBGandExit(st.dbg);
  }
  cc_named_vp : *VariablePayload = cc_named.payload;
  tp := cc_named_vp.alloc;


  self_ptr := LLVMBuildStructGEP2(cc.builder, tp, alloc, 0, "selfptr");
  LLVMBuildStore(cc.builder, val, self_ptr);

  // assign vptr -> 1

  vptr_ptr := LLVMBuildStructGEP2(cc.builder, tp, alloc, 1, "vptrptr");
  LLVMBuildStore(cc.builder, vptr, vptr_ptr);

  return;
}

resolve_struct := (e: *Expression, cc: *CC) -> *Statement {
  // return pointer to struct statement or null
  st := typeresolve(e, cc);
  while(st.type == TypeType.pointerT){
    st = st.payload;
  }
  if(st.type == TypeType.namedT){
    // might be a struct or interface
    c_name := cc_resolve_named(cc, strcat(st.payload, "$$"));
    if(!c_name){
      // struct
      c_name = cc_resolve_named(cc, st.payload);
      vp : *VariablePayload = c_name.payload;
      return vp.decl;
    }
  }
  return 0;
}

compile_base_assign := (base: *Expression, v: *Expression, cc: *CC) -> void{
  alloc := get_alloca(base, cc);
  val := exprgen(v, cc);

  // are we handling struct to interface?
  st := resolve_struct(v, cc);
  if(st){
    it := resolve_interface(base, cc);
    if(it){
      
      // handle levels (i.e., load alloc or val to get to the required level)
      // go down until there is exactly one level left!

      stt := typeresolve(v, cc);
      counter := 0;
      while(stt.type == TypeType.pointerT){
        stt = stt.payload;
        counter = counter + 1;
      }
      if(counter == 0){
        // TODO free previous val
        val = get_alloca(v, cc);
      }
      else while(counter > 1){
        val = LLVMBuildLoad(cc.builder, val, "stptr");
        counter = counter - 1;
      }

      itt := typeresolve(base, cc);
      counter = 0;
      while(itt.type == TypeType.pointerT){
        itt = itt.payload;
        counter = counter + 1;
      }

      while(counter){
        alloc = LLVMBuildLoad(cc.builder, alloc, "itptr");
        counter = counter - 1;
      }

      struct_to_interface_cast(it, st, alloc, val, cc);
      return;
    }
  }
  // TODO is this a function?
  if(LLVMGetTypeKind(LLVMTypeOf(val)) == 9){
    LLVMInstructionEraseFromParent(val);
    val = get_alloca(v, cc);
  }

  // TODO better conversion?
  if(LLVMGetTypeKind(LLVMTypeOf(alloc)) == 12){// alloc is pointer
      val = LLVMBuildBitCast(cc.builder, val, LLVMGetElementType(LLVMTypeOf(alloc)), "castval");
  }
  LLVMBuildStore(cc.builder, val, alloc);
  return;
}

compile_assign := (s: *Statement, cc: *CC) -> void{
  e : *Expression = malloc(sizeof Expression);
  e.dbg = copy_debug_info(s.dbg);
  e.type = EType.varE;
  e.p1 = s.p1;
  compile_base_assign(e, s.p2, cc);
  return;
}

compile_member_assign := (s: *Statement, cc: *CC) -> void{
  compile_base_assign(s.p1, s.p2, cc);
  return;
}

compile_ptr_assign := (s: *Statement, cc: *CC) -> void{
  e: *Expression = malloc(sizeof Expression);
  e.dbg = copy_debug_info(s.dbg);
  e.type = EType.ptrE;
  e.p1 = s.p1;
  compile_base_assign(e, s.p2, cc);
  return;
}

compile_decl := (s: *Statement, cc: *CC) -> void{
  // check to see if it has type
  type : *any = 0;
  if(s.p2 == 0){
    //resolve type using expr
    s.p2 = typeresolve(s.p3, cc);
  }
  type = typegen(s.p2, cc);

  tbuilder := LLVMCreateBuilderInContext(cc.context);

  f := LLVMGetFirstBasicBlock(LLVMGetBasicBlockParent(LLVMGetInsertBlock(cc.builder)));
  instr := LLVMGetFirstInstruction(f);
  LLVMPositionBuilder(tbuilder, f, instr);

  alloc := LLVMBuildAlloca(tbuilder, type, s.p1);

  LLVMDisposeBuilder(tbuilder);

  payload: *VariablePayload = malloc(sizeof VariablePayload);
  payload.alloc = alloc;
  payload.decl = s;
  cc_set_named(cc, s.p1, payload);

  if(s.p3){
    // LLVMBuildStore(cc.builder, exprgen(s.p3, cc), alloc);
    e : *Expression = malloc(sizeof Expression);
    e.dbg = copy_debug_info(s.dbg);
    e.type = EType.varE;
    e.p1 = s.p1;
    compile_base_assign(e, s.p3, cc);
  }
  return ;
}


compile_fcall := (s: *Statement, cc: *CC) -> void{
  e : *Expression = malloc(sizeof Expression);
  e.dbg = copy_debug_info(s.dbg);
  e.type = EType.fcallE;
  e.p1 = s.p1;
  e.p2 = s.p2;
  exprgen_fcall(e, cc);
  return;
}

compile_mcall := (s: *Statement, cc: *CC) -> void{
  e : *Expression = malloc(sizeof Expression);
  e.dbg = copy_debug_info(s.dbg);
  e.type =  EType.methodCallE;
  e.p1 = s.p1;
  e.p2 = s.p2;
  e.p3 = s.p3;
  exprgen_methodcall(e, cc);
  return;
}

compile_cb := (s: *Statement, cc: *CC) -> void{
  f : *Statement = s.p1;
  if(f)
    compile(f, cc);
  return;
}

compile_enum := (s: *Statement, cc: *CC) -> void{
  // TODO do I want to find another way for finding enums?
  // we don't need the extra field, but have to for struct compatibility
  vp : *VariablePayload = malloc(sizeof VariablePayload);
  vp.alloc = 0; // this means we have an enum
  vp.decl = s;
  cc_set_named(cc, s.p1, vp);
  return;
}

compile := (s: *Statement, cc: *CC) -> void{
  if(s.type == SType.returnT){ // return
    compile_ret(s, cc);
  } else if(s.type == SType.declT){ // declaration
    compile_decl(s, cc);
  } else if(s.type == SType.assignT){ // assign
    compile_assign(s, cc);
  } else if(s.type == SType.memAssignT){ // member
    compile_member_assign(s, cc);
  } else if(s.type == SType.fcallT){ // fcall
    compile_fcall(s, cc);
  } else if(s.type == SType.ifT){ // if
    compile_if(s, cc);
  } else if(s.type == SType.whileT){ // while
    compile_while(s, cc);
  } else if(s.type == SType.codeBlockT){ // codeblock
    compile_cb(s, cc);
  } else if(s.type == SType.ptrAssignT){ // ptr assign
    compile_ptr_assign(s, cc);
  } else if(s.type == SType.funcDefT){ // function
    compile_function(s, cc);
  } else if(s.type == SType.funcSignT){ // function signature
    compile_fs(s, cc);
  } else if(s.type == SType.structDefT){ // struct
    compile_struct(s, cc);
  } else if(s.type == SType.interfaceDefT){ // interface
    compile_interface(s, cc);
  } else if(s.type == SType.methodCallT){ // method call
    compile_mcall(s, cc);
  } else if(s.type == SType.enumDefT){ // enum
    compile_enum(s, cc);
  } else{
    printf("Unknown statement type %d\n", s.type);
    printDBGandExit(s.dbg);
    return;
  }
  if(s.next){
    compile(s.next, cc);
  }
  return;
}

main := (argc: s32,argv: *string) -> int{
  // We don't have a not operation yet
  if(argc != 2){
    printf("not enough arguments provided\n");
    return 1;
  }

  filename := *(argv +1);

  buf : string = 0;
  null : *int = 0;

  f := fopen(filename, "r");

  // We don't have not implemented yet...
  if(f){
  } else {
    printf("Could not open file\n");
    return 1;
  }

  if(fseek(f, 0, 2)){
    printf("unable to seek file\n");
    exit(1);
  }

  bufsize := ftell(f);
  // We don't have negatives yet.
  negOne := 0 -1;

  if(bufsize == negOne){
    printf("unable to read file\n");
    exit(1);
  }
  buf = malloc(sizeof u8 *(bufsize+1));

  if(fseek(f, 0, 0)){ // go back
    printf("unable to seek file\n");
    exit(1);
  }

  newLen := fread(buf, 1, bufsize, f);

  // just to be safe
  { // buf[newLen +1 ] = '\0';
    tmpB : *u8 = *buf;
    tmpB = tmpB + newLen + 1;
    tmpB = 0; // '\0'
  }

  // the file is no loaded, let's pass it to a lexer
  l := lexer(buf);

  ast := parser(l);

  cc: *CC = malloc(sizeof CC);
  cc.structNum = 0;
  cc.lastB = 0;

  push_bb(cc);

  cc.context = LLVMContextCreate();
  cc.module = LLVMModuleCreateWithNameInContext("module", cc.context);
  cc.builder = LLVMCreateBuilderInContext(cc.context);

  LLVMSetTarget(cc.module, "x86_64-pc-linux-gnu");
  LLVMSetDataLayout(cc.module, "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128");

  compile(ast, cc);


  printf("%s\n", LLVMPrintModuleToString(cc.module));

  CompileLLVM(cc.module, "out.o");

  return 0;
}
