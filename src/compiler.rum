// TODO Add & to every pre for all types
// TODO strcat optimize free
// TODO getValue is flawed for unnamed values (ex a+b)
// TODO tidy up Type definitions, remove opType etc
// == Helper & LLVM functions

malloc := (size: u64) -> *any;
free := (a: *any) -> void;
printf := (T: string, s: ...any)->void;
exit := (s: int) -> void;
atoi := (s: string) -> int;

fopen := (s: string, mod: string) -> *int;
fseek := (f: *int, offset: u64, whence: u32) -> int; // SEEK_END == 2, SEEK_SET == 0
ftell := (f: *int) -> int;
fread := (buf: string, size: int, nmemb: int, f: *int) -> int;

LLVMAddFunction := (m: *any, name: string, ftype: *any) -> *any;
LLVMInt1TypeInContext := (c: *any) -> *any;
LLVMInt8TypeInContext := (c: *any) -> *any;
LLVMInt16TypeInContext := (c: *any) -> *any;
LLVMInt32TypeInContext := (c: *any) -> *any;
LLVMInt64TypeInContext := (c: *any) -> *any;
LLVMVoidTypeInContext := (c: *any) -> *any;
LLVMInt1TypeInContext := (c: *any) -> *any;
LLVMInt8TypeInContext := (c: *any) -> *any;
LLVMInt16TypeInContext := (c: *any) -> *any;
LLVMInt32TypeInContext := (c: *any) -> *any;
LLVMInt64TypeInContext := (c: *any) -> *any;
LLVMFloatTypeInContext := (c: *any) -> *any;
LLVMDoubleTypeInContext := (c: *any) -> *any;
LLVMVoidTypeInContext := (c: *any) -> *any;
LLVMFunctionType := (returnType: *any, paramTypes: **any, paramCount: u64, isVarArg: bool) -> *any;
LLVMPointerType := (elemntType: *any, addresspace: u64) -> *any;
LLVMGetNamedFunction := (m: *any, name: string) -> *any;
LLVMAppendBasicBlockInContext := (c: *any, f: *any, name: string)-> *any;
LLVMGetInsertBlock := (b: *any) -> *any;
LLVMGetBasicBlockTerminator := (bb: *any) -> *any; // instruction
LLVMBuildBr := (b: *any, bb: *any) -> *any;
LLVMAppendExistingBasicBlock := (f: *any, bb: *any) -> void;
LLVMGetInstructionOpcode := (inst: *any) -> int;
LLVMCreateBasicBlockInContext := (c: *any, name: string) -> *any;
LLVMTypeOf := (val: *any) -> *any;
LLVMBuildIntCast2 := (b: *any, val: *any, dest: *any, signed: bool, name: string) -> *any;
LLVMPositionBuilder := (b: *any, bb: *any, inst: *any) -> void;
LLVMBuildICmp := (b: *any, op: int, lhs: *any, rhs: *any, name: string) -> *any;
LLVMConstInt := (t: *any, v: *any, signed: bool) -> *any;
LLVMBuildCondBr := (b: *any, cond: *any, bt: *any, bf: *any) -> *any;
LLVMGetBasicBlockParent := (bb: *any) -> *any;
LLVMGetParam := (f: *any, ind: u64) -> *any;
LLVMSetValueName2 := (v: *any, name: string, size: u64) -> void;
LLVMBuildCall := (b: *any, f: *any, args: *any, count: int, name: string) -> *any;
LLVMBuildAlloca := (b: *any, type: *any, name: string) -> *any;
LLVMBuildStore := (b: *any, val: *any, ptr: *any) -> void;
LLVMBuildLoad := (b: *any, ptr: *any, name: string) -> *any;
LLVMBuildStructGEP2 :=(b : *any, t: *any, ptr: *any, ind: int, name: string) -> *any;
LLVMBuildRet := (b: *any, v: *any) -> void;
LLVMBuildRetVoid := (b: *any) -> void;

LLVMStructCreateNamed := (c: *any, name: *string) -> *any;
LLVMStructSetBody := (t: *any, types: *any, count: int, packed: bool) -> void;

LLVMPrintModuleToString := (m: *any) -> string;
LLVMContextCreate := () -> *any;
LLVMModuleCreateWithNameInContext := (name: string, c: *any) -> *any;
LLVMCreateBuilderInContext := (c: *any) -> *any;
LLVMSetTarget := (m: *any, triple: string) -> void;
LLVMSetDataLayout := (m: *any, dl: string) -> void;

CompileLLVM := (m :* any, path: string) -> void;

streq := (s1: *u8, s2: *u8) -> bool{
  counter := 0;
  while(1){
    if(*(s1+ counter) != *(s2+counter)){
      return 0;
    }
    if(*(s1+counter) == 0)
      return 1;


    counter = counter + 1;
  }

  return 0; // unreachable
}

strlen := (s1: *u8) -> u64{
  size := 0;
  while(1){
    if((*(s1+size)) == 0)
      return size;
    size = size + 1;
  }
  return 0; // unreachable
}

strcat := (s1: *u8, s2: *u8) -> *u8{
  size := strlen(s1) + strlen(s2) + 1;
  ans : *u8 = malloc(size * sizeof u8);
  ptr := 0;
  ptr2 := 0;
  while(*(s1+ptr) != 0){
    *(ans+ptr) = *(s1+ptr);
    ptr = ptr + 1;
  }
  while(*(s2+ptr2) != 0){
    *(ans+ptr) = *(s2+ptr2);
    ptr = ptr + 1;
    ptr2 = ptr2 + 1;
  }
  *(ans+ptr) = 0;
  return ans;
}

is_alpha := (c: u8) -> bool{
  if(c >= 'a')
    if(c <= 'z')
      return 1;
  if(c >= 'A')
    if(c <= 'Z')
      return 1;
  return 0;
}

is_numeric := (c: u8) -> bool{
  if(c >= '0')
    if(c <= '9')
      return 1;
  return 0;
}

is_alphanumeric := (c: u8) -> bool{
  if(c == '_') // underline
    return 1;

  if(is_alpha(c))
    return 1;

  return is_numeric(c);
}

strcp := (buf: *u8, start: int, end: int) -> string{
  out : *u8 = malloc(sizeof u64 * (end - start));
  counter := start;
  while(counter != end){
    *(out + (counter - start)) = *(buf + counter);
    counter = counter + 1;
  }
  *(out + (end - start)) = 0; // '\0'
  return out;
}

// === enums

TokenType: enum{
  // it has a value so it doesn't start from 0
  TCOL=1, // :
  TDEF, // :=
  TLPAR, // (
  TRPAR, // )
  TCOMMA, // ,
  TDOT, // .
  T3DOT, // ...
  TARROW, // ->
  TSEM, // ;
  TSTAR, // *
  TLCB, // {
  TRCB, // }
  TEQ, // =
  TINT, // int
  TRET, // return
  TIF, // if
  TWHILE, // while
  TELSE, // else
  TSTR, // string
  TANY, // any
  TSTRUCT, // struct
  TVOID, // void
  TU8, // u8
  TU16, // u16
  TU32, // u32
  TU64, // u64
  TS8, // s8
  TS16, // s16
  TS32, // s32
  TS64, // s64
  TF32, // f32
  TF64, // f64
  TBOOL, // bool
  TSIZE, // sizeof
  TINTERFACE, // interface
  TENUM, // enum
  TINSTANCEOF,
}

// === structs & interfaces

DBG: struct{
  line: int;
}

DBG.printAndExit := () -> void{
  printf("line %d\n", self.line);
  exit(1);
  return ;
}

LinkedNode: struct{
  next: *LinkedNode;
  p: *any;
}

BB: struct{
  nv: *LinkedNode;
}

BB.init := () -> void{
  self.nv = 0;
  return;
}

CC: struct{
  cp: *LinkedNode;
  sp: *LinkedNode;
  bb: *LinkedNode;
  tp: *LinkedNode;
  module: *any;
  context: *any;
  builder: *any;
  namedNum: int;

  lastErr: string;

  buf: *u8;
  offset :int;
  line: int;
}

CC.init := () -> void{
  self.cp = 0;
  self.sp = 0;
  self.bb = malloc(sizeof LinkedNode);
  self.bb.p = malloc(sizeof BB);
  bb : *BB = self.bb.p;
  bb.init();
  self.namedNum = 0;
  self.offset = 0;
  self.line = 0;
  return;
}

CC.pushBlock := () -> void{
  bb: *BB = malloc(sizeof BB);
  bb.init();

  ln : *LinkedNode = malloc(sizeof LinkedNode);
  ln.next = self.bb;
  ln.p = bb;

  self.bb = ln;

  return;
}

CC.popBlock := () -> void{
  tmp := self.bb;
  self.bb = self.bb.next;
  free(tmp);
  return;
}

CC.getDBG := () -> *DBG{
  dbg : *DBG = malloc(sizeof DBG);
  
  dbg.line = self.line;

  return dbg;
}

CC.storeLexer := () -> *any{
  return self.offset;
}

CC.restoreLexer := (cp: *any) -> void{
  self.offset = cp;
  return;
}

CC.setError := (e: string) -> void{
  self.lastErr = e;
  return ;
}

CC.skipWS := () -> void{
  while(1){
    is_ws := 0;
    c : u8 = *(self.buf + self.offset);
    if(c == 10){// \n
      is_ws = 1;
      self.line = self.line + 1;
    }
    if(c == 32){ // space
      is_ws = 1;
    }

    if(c == 9){ // tab
      is_ws = 1;
    }

    if(is_ws==0) return;
    self.offset = self.offset + 1;
  }
  return;
}

CC.nextWord := () -> string{
  self.skipWS();
  buf := self.buf;
  offset := self.offset;
  if(is_alpha(*(buf+offset))){
    // we have a word
    end := self.offset + 1;
    while(is_alphanumeric(*(buf+end))){
      end = end  +1;
    }
    id := strcp(buf, offset, end);
    self.offset = end;
    return id;
  }
  return 0; // it wasn't a word
}

CC.isKeyword := (s: string) -> TokenType{
  if(streq(s, "int")) return TokenType.TINT;
  if(streq(s, "return")) return TokenType.TRET;
  if(streq(s, "if")) return TokenType.TIF;
  if(streq(s, "while")) return TokenType.TWHILE;
  if(streq(s, "else")) return TokenType.TELSE;
  if(streq(s, "string")) return TokenType.TSTR;
  if(streq(s, "any")) return TokenType.TANY;
  if(streq(s, "struct")) return TokenType.TSTRUCT;
  if(streq(s, "void")) return TokenType.TVOID;
  if(streq(s, "u8")) return TokenType.TU8;
  if(streq(s, "u16")) return TokenType.TU16;
  if(streq(s, "u32")) return TokenType.TU32;
  if(streq(s, "u64")) return TokenType.TU64;
  if(streq(s, "s8")) return TokenType.TS8;
  if(streq(s, "s16")) return TokenType.TS16;
  if(streq(s, "s32")) return TokenType.TS32;
  if(streq(s, "s64")) return TokenType.TS64;
  if(streq(s, "f32")) return TokenType.TF32;
  if(streq(s, "f64")) return TokenType.TF64;
  if(streq(s, "bool")) return TokenType.TBOOL;
  if(streq(s, "sizeof")) return TokenType.TSIZE;
  if(streq(s, "interface")) return TokenType.TINTERFACE;
  if(streq(s, "enum")) return TokenType.TENUM;
  if(streq(s, "instanceof")) return TokenType.TINSTANCEOF;
  return 0;
}

CC.isEOF := () -> bool{
  if(*(self.buf+self.offset) == 0) return 1;
  return 0;
}

CC.expectId := () -> string{
  word := self.nextWord();
  if(!word) return 0;
  if(self.isKeyword(word)) return 0;
  return word;
}

CC.expectNum := () -> *int{
  self.skipWS();
  buf := self.buf;
  offset := self.offset;
  if(is_numeric(*(buf+offset))){
    // we have a number, I think
    end := self.offset + 1;
    while(is_numeric(*(buf+end))){
      end = end + 1;
    }
    str := strcp(buf, offset, end);
    num := atoi(str);
    ans :*int = malloc(sizeof int);
    *ans = num;
    return ans;
  }
  return 0;
}

resolve_escape := (c: u8) -> u8{
  if(c == 'n'){// \n
    return '\n';
  } else if(c == 't'){
    return 9;
  } else { // handle \' and \" and \\
    return c;
  }
}

CC.expectChar := () -> *u8{
  if(*(self.buf+self.offset) == '\''){
    // set error
    self.setError("Empty character literal");
    return 0;
  }
  ans : *u8 = malloc(sizeof u8);
  *ans = *(self.buf+self.offset);
  self.offset = self.offset + 1;
  if(*ans == '\\'){
    *ans = resolve_escape(*(self.buf+self.offset));
    self.offset = self.offset + 1;
  }
  return ans;
}

CC.expectString := () -> string{
  end := self.offset+1;
  buf := self.buf;
  while(1){
    if(*(buf+end) == '"'){ // "
      return end + 1;
    }
    if(*(buf+end) == '\n'){ // newline
      self.setError("Unclosed string literal");
      return 0;
    }

    if(*(buf+end) == '\\'){ // \ 
      end = end + 1; // skip the next one, whatever it might be.
    }
    end = end + 1;
  }

  ind := 0;
  offset := self.offset + 1; // ignore "
  self.offset = end;
  end = end - 1; // ignore "
  size := end - offset;
  // out : *u8 = malloc(2 * (size+4)); // not sure why we need +4 here.
  out :*u8 = malloc(sizeof u8*(size+1));

  while(end - offset){
    *(out + ind) = *(buf + offset);

    if(*(buf + offset) == '\\'){
      // handle special cases
      offset = offset + 1;
      *(out + ind) = resolve_escape(*(buf+offset));
    }

    offset = offset + 1;
    ind = ind + 1;
  }

  *(out + ind) = 0;

  return out;
}

tokenkeywordtostring := (t: *TokenType) -> string{
  if(t == TokenType.TINT) return "int";
  if(t == TokenType.TRET) return "return";
  if(t == TokenType.TIF) return "if";
  if(t == TokenType.TWHILE) return "while";
  if(t == TokenType.TELSE) return "else";
  if(t == TokenType.TSTR) return "string";
  if(t == TokenType.TANY) return "any";
  if(t == TokenType.TSTRUCT) return "struct";
  if(t == TokenType.TVOID) return "void";
  if(t == TokenType.TU8) return "u8";
  if(t == TokenType.TU16) return "u16";
  if(t == TokenType.TU32) return "u32";
  if(t == TokenType.TU64) return "u64";
  if(t == TokenType.TS8) return "s8";
  if(t == TokenType.TS16) return "s16";
  if(t == TokenType.TS32) return "s32";
  if(t == TokenType.TS64) return "s64";
  if(t == TokenType.TF32) return "f32";
  if(t == TokenType.TF64) return "f64";
  if(t == TokenType.TBOOL) return "bool";
  if(t == TokenType.TSIZE) return "sizeof";
  if(t == TokenType.TINTERFACE) return "interface";
  if(t == TokenType.TENUM) return "enum";
  if(t == TokenType.TINSTANCEOF) return "instanceof";
  return 0;
}

CC.expectToken := (t: TokenType) -> bool{
  self.skipWS();
  buf := self.buf;
  offset := self.offset;
  ch := *(buf+offset);
  if(t == TokenType.TCOL){
    if(ch == ':'){
      if(*(buf+offset+1) != '='){
        self.offset = offset + 1;
        return 1;
      }
    }
    self.lastErr = "Expected :";
    return 0;
  }
  if(t == TokenType.TDEF){
    if(ch == ':')
      if(*(buf+offset+1) == '='){
        self.offset = offset + 2;
        return 1;
      }
    self.lastErr = "Expected :=";
    return 0;
  }
  if(t == TokenType.TLPAR){
    if(ch == '('){
      self.offset = offset + 1;
      return 1;
    }
    self.lastErr = "Expected (";
    return 0;
  }
  if(t == TokenType.TRPAR){
    if(ch == '('){
      self.offset = offset + 1;
      return 1;
    }
    self.lastErr = "Expected )";
    return 0;
  }
  if(t == TokenType.TCOMMA){
    if(ch == ','){
      self.offset = offset + 1;
      return 1;
    }
    self.lastErr = "Expected ,";
    return 0;
  }
  if(t == TokenType.TDOT){
    if(ch == '.')
      if(*(buf+offset+1!='.')){
        self.offset = offset + 1;
        return 1;
      }
    self.lastErr = "Expected .";
    return 0;
  }
  if(t == TokenType.T3DOT){
    if(ch == '.')
      if(*(buf+offset+1=='.'))
        if(*(buf+offset+2=='.')){
          self.offset = offset + 3;
          return 1;
        }
    self.lastErr = "Expected ...";
    return 0;
  }
  if(t == TokenType.TARROW){
    if(ch == '-')
      if(*(buf+offset+1=='>')){
        self.offset = offset + 2;
        return 1;
      }
    self.lastErr = "Expected ->";
    return 0;
  }
  if(t == TokenType.TSEM){
    if(ch == ';'){
      self.offset = offset + 1;
      return 1;
    }
    self.lastErr = "Expected ;";
    return 0;
  }
  if(t == TokenType.TSTAR){
    if(ch == '*'){
      self.offset = offset + 1;
      return 1;
    }
    self.lastErr = "Expected *";
    return 0;
  }
  if(t == TokenType.TLCB){
    if(ch == '{'){
      self.offset = offset + 1;
      return 1;
    }
    self.lastErr = "Expected {";
    return 0;
  }
  if(t == TokenType.TRCB){
    if(ch == '}'){
      self.offset = offset + 1;
      return 1;
    }
    self.lastErr = "Expected }";
    return 0;
  }
  if(t == TokenType.TEQ){
    if(ch == '=')
      if(*(buf+offset+1) != '='){
        self.offset = offset + 1;
        return 1;
      }
    self.lastErr = "Expected =";
    return 0;
  }
  word := self.nextWord();
  if(!word) return 0;
  if(self.isKeyword(word) == t) return 1;
  self.lastErr = strcat("Expected keyword %s\n", tokenkeywordtostring(t));
  return 0;
}

Value: interface{
  getType := (cc: *CC) -> *Type; // typeof val
  getValue := (cc: *CC) -> *any; // = val
  // assignGen assumes cast has been called
  assignGen := (cc: *CC, val: *Value) -> void; // val = 
  preOpGen := (cc: *CC, op: string) -> *Value; // - val || *val
  postOpGen := (cc: *CC, op: string) -> *Value; // val++
  binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value; // val * rhs
  callGen := (cc: *CC, args: *LinkedNode) -> *Value; // val ()
  memberGen := (cc: *CC, name: string) -> *Value; // val.
  castGen := (cc: *CC, target: *Type) -> *Value; // val -> target
}

// Types aren't always instansiable, they could be general concepts as well.
Type: interface{
  getName := (cc: *CC) -> string;
  typegen := (cc: *CC) -> *any; // Needed for function pointers and structs

  getInstance := (cc: *CC, val: *any, name: string) -> *Value; // if val = 0 don't store

  cast := (cc: *CC, target: *Type) -> bool;

  assignCheck := (cc: *CC, t: *Type) -> bool;
  preOpType := (cc: *CC, op: string) -> *Type;
  postOpType := (cc: *CC, op: string) -> *Type;
  binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type;
  callType := (cc: *CC, args: *LinkedNode) -> *Type;
  memberType := (cc: *CC, name: string) -> *Type;

  size := (cc: *CC) -> *int; // int bytes
}

Named: struct{
  name: string;
  v: *Value;
}

CC.registerNamed := (name: string, v: *Value) -> void{
  named: *Named = malloc(sizeof Named);
  named.name = name;
  named.v = v;
  bb : *BB = self.bb.p;
  ln : *LinkedNode = malloc(sizeof LinkedNode);
  ln.p = named;
  ln.next = bb.nv;
  bb.nv = ln;
  return;
}

CC.resolveNamed := (name: string) -> *Value{
  bln: *LinkedNode = self.bb;
  while(bln){
    b: *BB = bln.p;
    ln : *LinkedNode = b.nv;
    while(ln){
      n: *Named = ln.p;
      if(streq(n.name, name)){
        return n.v;
      }
      ln = ln.next;
    }
    bln = bln.next;
  }
  return 0;
}

TypeTypeConcept: interface{
  staticMemberType := (cc: *CC, name: string) -> *Type;
  staticMemberGen := (cc: *CC, name: string) -> *Value;
}

TypeType: struct{
  baseContext: *TypeTypeConcept;
}

TypeType.size := (cc: *CC) -> int{
  return 0; // TODO
}
TypeType.getName := (cc: *CC) -> string{
  return "type";
}
TypeType.typegen := (cc: *CC) -> *any{
  return 0;
}
TypeType.getInstance := (cc: *CC, val: *any, name: string) -> *Value{ // Should I return myself?
  return 0;
}
TypeType.cast := (cc: *CC, target: *Type) -> bool{
  return 0;
}
TypeType.assignCheck := (cc: *CC, op: string) -> bool{
  return 0;
}
TypeType.preOpType := (cc: *CC, op: string) -> *Type{ return 0; }
TypeType.postOpType := (cc: *CC, op: string) -> *Type{ return 0; }
TypeType.binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type{ return 0; }
TypeType.callType := (cc: *CC, args: *LinkedNode) -> *Type { return 0; }
TypeType.memberType := (cc: *CC, name: string) -> *Type{
  return self.baseContext.staticMemberType(cc, name);
}

Arg: interface{
  getName := (cc: *CC) -> string;
  // register and assign val to itself
  codegen := (cc: *CC, val: *any) -> void; // val is the param provided
  typeresolve := (cc: *CC) -> *Type;
  isVarArg := (cc: *CC) -> bool;
}

BasicArg: struct{
  id: string;
  type: *Type;
  isvararg: bool;
}
BasicArg.getName := (cc: *CC) -> string { return self.id; }
BasicArg.typeresolve := (cc: *CC) -> *Type{ return self.type; }
BasicArg.codegen := (cc: *CC, val:*any) -> void{
  // instantiate a variable and assign it
  v := self.type.getInstance(cc, val, self.id);
  // set named
  cc.registerNamed(self.id, v);
  return;
}
BasicArg.isVarArg := (cc: *CC) -> bool{
  return self.isvararg;
}

Member: struct{
  id: string;
  type: *Type;
}

FunctionType: struct{
  dbg: *DBG;
  returnType: *Type;
  args: *LinkedNode; // of Type Arg
}

TParser: interface{
  parse := (cc: *CC) -> *Type;
  getName := (cc: *CC) -> string;
}

CC.expectType := () -> *Type{
  tp := self.tp;
  checkPoint := self.storeLexer();
  err: string = strcat("",""); // make it dynamic
  while(tp){
    p: *TParser = tp.p;
    out := p.parse(self);
    if(out){
      free(err);
      return out;
    }
    e := self.lastErr;
    err = strcat(err, strcat("\n", e));
    self.restoreLexer(checkPoint);
    tp = tp.next;
  }
  self.setError(err);
  return 0;
}

CC.registerTP := (tp: *TParser) -> void{
  tmp: *LinkedNode = malloc(sizeof LinkedNode);
  tmp.p = tp;
  tmp.next = self.tp;
  self.tp = tmp;
  return;
}

FunctionType.getName := (cc: *CC) -> void{
  ans := "(";
  a := self.args;
  while(a){
    arg :*Arg= a.p;
    t := arg.typeresolve(cc);
    ans = strcat(ans, t.getName(cc));
    if(a.next) ans = strcat(ans, ", ");
    a = a.next;
  }
  ans = strcat(ans, ") -> ");
  ans = strcat(ans, self.returnType.getName(cc));
  return ans;
}
FunctionType.typegen := (cc: *CC) -> *any{
  has_varargs := 0;
  args_count := 0;
  {
    argL: *LinkedNode = self.args;
    while(argL){
      args_count = args_count + 1;
      argL = argL.next;
    }
  }
  args := malloc(args_count * sizeof *any);
  argL: *LinkedNode = self.args;
  count := 0;
  while(argL){
    arg: *Arg = argL.p;
    t := arg.typeresolve(cc);
    *(args+count) = t.typegen(cc);
    count = count + 1;
    argL = argL.next;
    if(!argL) has_varargs = arg.isVarArg(cc);
  }

  // TODO memoize?
  return LLVMFunctionType(self.returnType.typegen(cc), args, args_count, has_varargs);
}
FunctionType.getInstance := (cc: *CC, val: *any, name: string) -> *Value {return 0;} // TODO?
FunctionType.cast := (cc: *CC, target: *Type) -> bool{
  return 0; // not castable for now
}
FunctionType.preOpType := (cc: *CC, op: string) -> *Type{
  return 0;
}
FunctionType.postOpType := (cc: *CC, op: string) -> *Type{
  return 0;
}
FunctionType.binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type{
  return 0;
}
FunctionType.memberType := (cc: *CC, name: string) -> *Type{
  return 0;
}
FunctionType.callType := (cc: *CC) -> *Type{
  return self.returnType;
}
FunctionType.assignCheck := (cc: *CC, t: *Type) -> bool{
  return 0;
}
FunctionType.size := (cc: *CC) -> int{ return 0; } // TODO

CC.expectFType := () -> *FunctionType{
  dbg := self.getDBG();
  if(!self.expectToken(TokenType.TLPAR)) return 0;
  whilecond := !self.expectToken(TokenType.TRPAR);

  first: *LinkedNode = 0;
  last: *LinkedNode = 0;

  while(whilecond){
    id := self.expectId();
    if(!id) return 0;
    if(!self.expectToken(TokenType.TCOL)) return 0;
    isvararg := self.expectToken(TokenType.T3DOT);
    t := self.expectType();
    if(!t) return 0;

    ba: *BasicArg = malloc(sizeof BasicArg);
    ba.id = id;
    ba.type = t;
    ba.isvararg = isvararg;

    a: *Arg = malloc(sizeof Arg);
    a = ba;

    tl: *LinkedNode = malloc(sizeof LinkedNode);
    tl.next = 0;
    tl.p = a;
    if(!first) first = tl;
    if(last) last.next = tl;
    last = tl;

    if(!self.expectToken(TokenType.TCOMMA)){
      if(!self.expectToken(TokenType.TRPAR)) return 0;
      whilecond = 0;
    }
  }
  if(!self.expectToken(TokenType.TARROW)) return 0;
  rtype := self.expectType();
  // ====
  tr: *FunctionType = malloc(sizeof FunctionType);
  tr.args = first;
  tr.returnType = rtype;
  tr.dbg = dbg;

  t : *Type = malloc(sizeof Type);
  t = tr;
  return t;
}

Concept: interface{
  getName := (cc: *CC) -> string;
  register := (cc: *CC) -> void; // Just add the name to CC and module
  compile := (cc: *CC) -> void; // Perform codegen
}

CParser: interface{
  parse := (cc: *CC) -> *Concept;
  getName := (cc: *CC) -> string;
}

CC.registerCP := (cp: *CParser) -> void{
  tmp : *LinkedNode = malloc(sizeof LinkedNode);
  tmp.p = cp;
  tmp.next = self.cp;
  self.cp = tmp;
  return;
}

Statement: interface{
  getName := (cc: *CC) -> string;
  codegen := (cc: *CC) -> void;
}

SParser: interface{
  parse := (cc: *CC) -> *Statement;
  getName := (cc: *CC) -> string;
}

CC.expectStatement := () -> *Statement{
  sp := self.sp;
  checkPoint := self.storeLexer();
  err : string = strcat("", ""); // just so it's dynamic
  while(sp){
    p: *SParser = sp.p;
    out := p.parse(self);
    if(out){
      free(err);
      return out;
    }
    e := self.lastErr;
    err = strcat(err, strcat("\n", e));
    self.restoreLexer(checkPoint);
    sp = sp.next;
  }
  self.setError(err);
  return 0;
}

CC.registerSP := (sp: *SParser) -> void{
  tmp : *LinkedNode = malloc(sizeof LinkedNode);
  tmp.p = sp;
  tmp.next = self.sp;
  self.sp = tmp;
  return;
}

/*
   A value of 0 means that this is not an op.
   A higher value should be resolved later.
*/
op_prec := (c: u8) -> int{
  if(c == '!') return 1;
  if(c == '/') return 2;
  if(c == '*') return 2;
  if(c == '%') return 2;
  if(c == '+') return 3;
  if(c == '-') return 3;
  if(c == '|') return 4;
  if(c == '&') return 4;
  if(c == '=') return 5;
  if(c == '<') return 5;
  if(c == '>') return 5;
  return 0;
}

compound_op_prec := (s: *u8) -> int{
  ans := op_prec(*s);
  if(!ans) return 0;
  t := s+1;
  while(*t){
    ans = ans * op_prec(*t);
    t = t + 1;
  }
  return ans;
}

CC.expectOp := () -> string{
  self.skipWS();
  offset := self.offset;
  end := self.offset;
  while(op_prec(*(self.buf+end))){
    end = end + 1;
  }

  if(offset == end)
    return 0;

  ans:=strcp(self.buf, offset, end);

  if(streq(ans, "=")){
    free(ans);
    return 0;
  }
  return ans;
}

Expr: struct{
  pre: string; // nullable

  // only one is set
  inner: *Expr;
  str: string;
  char: *u8;
  number: *int;
  id: string;
  sizeOf: *Type;

  // ==
  member: *Expr;

  // only one is set
  instanceOf: *Type;
  isCall: bool;

  // if isCall is set...
  firstArg: *LinkedNode; // of Value

  // Only one is set
  post: string;
  bin: string;

  // if bin is set...
  rhs: *Expr;
  prec : int;
}

newExpr := () -> *Expr{
  e: *Expr = malloc(sizeof Expr);

  e.pre = 0;

  e.inner = 0;
  e.str = 0;
  e.char = 0;
  e.number = 0;
  e.id = 0;
  e.sizeOf = 0;

  e.member = 0;

  e.instanceOf = 0;
  e.isCall = 0;

  e.firstArg = 0;

  e.post = 0;
  e.bin = 0;

  e.rhs = 0;
  e.prec = 0;
}

CC.expectExpression := () -> *Value{ return ; }  // Forward Declaration

CC.parseVal := () -> *Expr{

  exp: *Expr = newExpr();

  if(*(self.buf+self.offset) == '"'){ // "
    // const str
    exp.str = self.expectString();
    if(!exp.str) return 0;
  } else if(*(self.buf+self.offset) == '\''){
    // const char
    c := self.expectChar();
    if(!c) return 0;
    exp.char = c;
  } else if(is_numeric(*(self.buf+self.offset))){
    // number
    tmp := self.expectNum();
    if(!tmp) return 0;
    exp.number = tmp;
  } else if(is_alpha(*(self.buf+self.offset))){
    // variable
    // sizeof
    exp.id = self.expectId();
    if(!exp.id){
      if(self.expectToken(TokenType.TSIZE)){
        exp.sizeOf = self.expectType();
        if(!exp.sizeOf) return 0;
        return exp;
      }
      self.setError("no value was provided");
      return 0;
    }
  } else return 0;

  self.skipWS();
  last := exp;
  while(*(self.buf+self.offset) == '.'){
    // members
    self.skipWS();
    m := newExpr();
    last.member = m;
    m.id = self.expectId();
    last = m;
  }

  if(self.expectToken(TokenType.TINSTANCEOF)){
    // instanceof
    exp.instanceOf = self.expectToken();
    if(!exp.instanceOf) return 0;
  } else if(self.expectToken(TokenType.TLPAR)){
    // It's a call
    whilecond := !self.expectToken(TokenType.TRPAR);
    first: *LinkedNode = 0;
    pre: *LinkedNode = 0;
    while(whilecond){

      tmp := self.expectExpression();

      l : *LinkedNode = malloc(sizeof LinkedNode);
      l.p = tmp;
      l.next = 0;

      if(!first) first = l;
      if(pre) pre.next = l;
      pre = l;

      if(!self.expectToken(TokenType.TCOMMA))
        if(!self.expectToken(TokenType.TRPAR))
          return 0;
        else whilecond = 0;
    }
    exp.isCall = 1;
    exp.firstArg = first;
  }

  return exp;
}

CC.parseExpr := () -> *Expr{

  exp : *Expr;

  pre := self.expectOp();

  if(self.expectToken(TokenType.TLPAR)){
    // parenthesis ?
    exp = newExpr();
    tmp := self.parseExpr();
    if(!tmp) return 0;
    exp.inner = tmp;
    if(!self.expectToken(TokenType.TRPAR)) return 0;
  } else {
    // or value
    exp = self.parseVal();
    if(!exp) return 0;
  }

  exp.pre = pre;

  post := self.expectOp(); // This could be binary as well

  if(post){
    rhs := self.parseExpr();
    if(!rhs){
      // postop
      exp.post = post;
    } else {
      // binop
      prec := compound_op_prec(post);

      exp.prec = prec;
      exp.bin = post;
      exp.rhs = rhs;

      if(rhs.bin){
        if(rhs.prec < prec){

          ans := newExpr();

          ans.inner = exp;
          ans.bin = rhs.bin;
          ans.rhs = rhs.rhs;

          rhs.rhs = 0;
          rhs.bin = 0;

          ans.prec = rhs.prec;

          return ans;
        }
        exp.prec = rhs.prec;
      }
    }
  }

  return exp;
}

constStrVal := (s: string) -> *Value; // TODO
constCharVal := (u: u8) -> *Value; // TODO
constIntVal := (i: int) -> *Value; // TODO

CC.expToVal := (e: *Expr) -> *Value{
  v: *Value;
  // Base
  // inner
  if(e.inner) v = self.expToVal(e.inner);
  // str
  if(e.str) v = constStrVal(e.str);
  // char
  if(e.char) v = constCharVal(*e.char);
  // number
  if(e.number) v = constIntVal(*e.number);
  // id
  if(e.id) v = self.resolveNamed(e.id);
  if(!v) {
    self.setError(strcat("Variable ", strcat(e.id, " not found")));
    return 0;
  }
  // sizeof
  if(e.sizeOf) v = constIntVal(e.sizeOf.size(self));

  // TODO member

  // TODO isCall

  // TODO instanceOf

  // TODO pre

  // TODO post
  // TODO bin
  return v;
}

CC.expectExpression := () -> *Value{
  checkPoint := self.storeLexer();
  // Expressions
  exp := self.parseExpr();
  if(exp){
    return self.expToVal(exp);
  }

  self.setError(strcat("Couldn't parse expression, ", self.lastErr));
  self.restoreLexer(checkPoint);
  return 0;
}

// ==== TOP LEVELs
FunctionConcept: struct{
  dbg: *DBG;
  id: string;
  type: *FunctionType;
  firstS: *LinkedNode; // could be null on signatures
  hasBody: bool;
}
FunctionConcept.getName := (cc: *CC) -> string{
  return strcat("function ", self.id);
}
FunctionConcept.getType := (cc: *CC) -> *Type{
  t: *Type = malloc(sizeof Type);
  t = self.type;
  return t;
}
FunctionConcept.compile := (cc: *CC) -> void{
  if(!self.hasBody) return;

  f := LLVMGetNamedFunction(cc.module, self.id);
  bblock := LLVMAppendBasicBlockInContext(cc.context, f, "entry");

  cc.pushBlock();

  argL : *LinkedNode = self.type.args;
  count := 0;
  while(argL){
    arg : *Arg = argL.p;
    param := LLVMGetParam(f, count);
    LLVMSetValueName2(param, arg.getName(), strlen(arg.getName()));

    arg.codegen(cc, param); // ?

    argL = argL.next;
    count = count + 1;
  }

  stmt := self.firstS;
  while(stmt){
    s : *Statement = stmt.p;
    s.codegen(cc);

    stmt = stmt.next;
  }

  cc.popBlock();
  return;
}
FunctionConcept.assignGen := (cc: *CC, val: *Value) -> *any{
  return 0;
}
FunctionConcept.preOpGen := (cc: *CC, op: string)-> *Value{
  return 0;
}
FunctionConcept.postOpGen := (cc: *CC, op: string)-> *Value{
  return 0;
}
FunctionConcept.binOpGen := (cc: *CC, op: string, rhs: *Value)-> *Value{
  return 0;
}
FunctionConcept.castGen := (cc: *CC, target: *Type) -> *Value{
  return 0;
}
FunctionConcept.memberGen := (cc: *CC, name: string) -> * Value{
  return 0;
}
FunctionConcept.callGen := (cc: *CC, args: *LinkedNode) -> *Value{
  count := 0;
  argL := args;
  while(argL){
    argL = argL.next;
    count = count + 1;
  }

  args := malloc(count * sizeof *any);
  argL = args;
  count = 0;
  while(argL){
    arg : *Value = argL.p;
    *(args+count) = arg.getValue(cc);
    argL = argL.next;
    count = count + 1;
  }
  name := "retval";
  f := LLVMGetNamedFunction(cc.module, self.id);
  val := LLVMBuildCall(cc.builder, f, args, count, name);
  // Now create a value...
  return self.type.returnType.getInstance(cc, val, "retval");
}
FunctionConcept.getValue := (cc: *CC) -> *any{
  return LLVMGetNamedFunction(cc.module, self.id);
}
FunctionConcept.register := (cc: *CC) -> void{
  // LLVM Register
  ftype := self.type.typegen(cc);
  LLVMAddFunction(cc.module, self.id, ftype);

  // CC Register
  v: *Value = malloc(sizeof Value);
  v = self;
  cc.registerNamed(self.id, v);
  return;
}
FunctionSigParser: struct{}
FunctionSigParser.getName := (cc: *CC) -> string{
  return "function signature";
}
FunctionSigParser.parse := (cc: *CC) -> *Concept{
  dbg := cc.getDBG();

  id := cc.expectId();
  if(!id) return 0;
  if(!cc.expectToken(TokenType.TDEF)) return 0;
  ftype := cc.expectFType();
  if(!ftype) return 0;
  if(!cc.expectToken(TokenType.TSEM)) return 0;

  fs : *FunctionConcept = malloc(sizeof FunctionConcept);
  fs.dbg = dbg;
  fs.id = id;
  fs.type = ftype;
  fs.firstS = 0;
  fs.hasBody = 0;

  ctx : *Concept = malloc(sizeof Concept);
  ctx = fs;

  return ctx;
}

FunctionDefineParser : struct{}
FunctionDefineParser.getName := (cc: *CC) -> string{
  return "function define";
}
FunctionDefineParser.parse := (cc: *CC) -> *Concept{
  dbg := cc.getDBG();

  id := cc.expectId();
  if(!id) return 0;
  if(!cc.expectToken(TokenType.TDEF)) return 0;
  ftype := cc.expectFType();
  if(!ftype) return 0;
  if(!cc.expectToken(TokenType.TLCB)) return 0;

  first : *LinkedNode = 0;
  c : *LinkedNode = 0;
  while(!cc.expectToken(TokenType.TRCB)){
    tmp := cc.expectStatement();

    if(!tmp)
      return 0;

    ltmp : *LinkedNode = malloc(sizeof LinkedNode);
    ltmp.p = tmp;
    ltmp.next = 0;

    if(!first)
      first = ltmp;
    if(c)
      c.next = ltmp;
    c = ltmp;
  }

  fd : *FunctionConcept = malloc(sizeof FunctionConcept);
  fd.dbg = dbg;
  fd.id = id;
  fd.type = ftype;
  fd.firstS = first;
  fd.hasBody = 1;
   
  ctx : *Concept = malloc(sizeof Concept);
  ctx = fd;

  return ctx;
}

StructConcept: struct{
  dbg: *DBG;
  id: string;
  first: *LinkedNode;
  // Methods are only stored, they should be compiled elsewhere
  firstMethod: *LinkedNode; // Link to concepts
  s: *any;
  namedNum: int;
}

StructInstance: struct{
  alloc: *any;
  sc: *StructConcept;
}

StructInstance.getType := (cc: *CC) -> *Type{return ;} // This is a dummy definition, redifined later on

StructInstance.getValue := (cc: *CC) -> *any{
  return LLVMBuildLoad(cc.builder, self.alloc, "sval");
}

StructInstance.preOpGen := (cc: *CC, op: string) -> *Value{
  return 0;
}
StructInstance.postOpGen := (cc: *CC, op: string) -> *Value{
  return 0;
}
StructInstance.binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value{
  return 0;
}
StructInstance.callGen := (cc: *CC, arg: *LinkedNode) -> *Value{
  return 0;
}
StructInstance.memberGen := (cc: *CC, name: string) -> *Value{
  // resolve index
  ind := 0;
  l: *LinkedNode = self.sc.first;
  while(l){
    m : *Member = l.p;
    if(streq(m.id, name)){
      // create GEP
      mem := LLVMBuildStructGEP2(cc.builder, self.alloc, self.sc.s, ind);
      // cast to value
      v := m.type.getInstance(cc, mem, "memaccess");
      return v;
    }
    ind = ind + 1;
    l = l.next;
  }
  // TODO raise error?
  return 0;
}
StructInstance.castGen := (cc: *CC, t: *Type) -> *Value{
  // TODO cast to interfaces here
  return 0;
}

StructInstance.assignGen := (cc: *CC, val: *Value) -> void{
  LLVMBuildStore(cc.builder, val.getValue(), self.alloc);
  return;
}

StructConcept.size := (cc: *CC) -> int{
  return 0; // TODO
}
StructConcept.getName := (cc: *CC) -> string{
  return strcat("struct ", self.id);
}
StructConcept.typegen := (cc: *CC) -> *any{
  return self.s;
}
StructConcept.cast := (cc: *CC, target: *Type) -> bool{
  // Do not cast to interface, this is struct type not struct instance
  return 0;
}
StructConcept.preOpType := (cc: *CC, op: string) -> *Type {return 0;}
StructConcept.preOpGen := (cc: *CC, op:string) -> *Value {return 0;}
StructConcept.postOpType := (cc: *CC, op: string) -> *Type {return 0;}
StructConcept.postOpGen := (cc: *CC, op:string) -> *Value {return 0;}
StructConcept.binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type {return 0;}
StructConcept.binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value {return 0;}
StructConcept.assignGen := (cc: *CC, v: *Value) -> *Value {return 0;}
StructConcept.getInstance := (cc: *CC, val: *any, name: string) -> *Value {
  // instantiate a struct
  si : *StructInstance = malloc(sizeof StructInstance);
  si.sc = self;
  si.alloc = LLVMBuildAlloca(cc.builder, self.s, name);
  if(val) LLVMBuildStore(cc.builder, val, si.alloc);
  v: *Value = malloc(sizeof Value);
  v = si;
  return v;
}
StructConcept.callType := (cc: *CC, args: *LinkedNode) -> *Type {return 0;}
StructConcept.callGen := (cc: *CC, args: *LinkedNode) -> *Value{return 0;}
StructConcept.castGen := (cc: *CC, target: *Type) -> *Value{return 0;}
StructConcept.memberType := (cc: *CC, name: string) -> *Type{
  // We don't check members, because this is the struct concept, not struct instance
  // TODO check methods
  return 0;
}
StructConcept.memberGen := (cc: *CC, name: string) -> *Value{
  // TODO check methods only
  return 0;
}
StructConcept.staticMemberType := (cc: *CC, name: string) -> *Type{
  // TODO handle methods
  return 0;
}
StructConcept.staticMemberGen := (cc: *CC, name: string) -> *Value{
  // TODO handle methods
  return 0;
}
StructConcept.getValue := (cc: *CC) -> *any{
  return self.s;
}
StructConcept.assignCheck := (cc: *CC, t: *Type) -> bool{
  return 0;
}
StructConcept.getType := (cc: *CC) -> *Type{
  ttc: *TypeTypeConcept = malloc(sizeof TypeTypeConcept);
  ttc = self;
  tt: *TypeType = malloc(sizeof TypeType);
  tt.baseContext = ttc;
  t: *Type = malloc(sizeof Type);
  t = tt;
  return t;
}
StructInstance.getType := (cc: *CC) -> *Type{
  t : *Type = malloc(sizeof Type);
  t = self.sc;
  return t;
}
StructConcept.register := (cc: *CC) -> void{
  self.s = LLVMStructCreateNamed(cc.context, self.id);

  self.namedNum = cc.namedNum + 1;
  self.namedNum = cc.namedNum;

  v: *Value = malloc(sizeof Value);
  v = self;
  cc.registerNamed(self.id, v);
  return;
}
StructConcept.compile := (cc: *CC) -> void{
  count := 0;
  l := self.first;
  while(l){
    l = l.next;
    count = count + 1;
  }
  members : *any = malloc(sizeof *any * count);
  l = self.first;
  i := 0;
  while(l){
    tmpp := l.p;
    mem: *Member = tmpp;
    *(members+i) = mem.type.typegen(cc);
    l = l.next;
    i = i+1;
  }

  // TODO change packed?
  LLVMStructSetBody(self.s, members, count, 0);

  return;
}

StructDefineParser: struct{}
StructDefineParser.getName := (cc: *CC) -> string{
  return "struct";
}
StructDefineParser.parse := (cc: *CC) -> *Concept{
  dbg := cc.getDBG();

  id := cc.expectId();
  if(!id) return 0;
  if(!cc.expectToken(TokenType.TCOL)) return 0;
  if(!cc.expectToken(TokenType.TSTRUCT)) return 0;
  if(!cc.expectToken(TokenType.TLCB)) return 0;

  first : *LinkedNode = 0;
  prev: *LinkedNode = 0;
  while(!cc.expectToken(TokenType.TRCB)){
    mid := cc.expectId();
    if(!mid) return 0;
    if(!cc.expectToken(TokenType.TCOL)) return 0;
    t := cc.expectType();
    if(!t) return 0;

    m : *Member = malloc(sizeof Member);
    m.id = mid;
    m.type = t;

    tmp : *LinkedNode = malloc(sizeof LinkedNode);
    tmp.p = m;
    tmp.next = 0;

    if(!first)
      first = tmp;
    if(prev)
      prev.next = tmp;
    prev = tmp;
  }
  if(!cc.expectToken(TokenType.TRCB)) return 0;

  sd : *StructConcept = malloc(sizeof StructConcept);
  sd.dbg = dbg;
  sd.id = id;
  sd.first = first;
  sd.s = 0;
  sd.firstMethod = 0;

  ctx: *Concept = malloc(sizeof Concept);
  ctx = sd;

  return ctx;
}

InterfaceConcept : struct{
  dbg: *DBG;
  id: string;
  first: *LinkedNode;
  vptr: *any;
  holder: *any;
}

InterfaceInstance : struct{
  alloc: *any;
  ic: *InterfaceConcept;
}

InterfaceInstance.getType := (cc: *CC) -> *Type{return ;} // This is a dummy definition, redifined later on

InterfaceInstance.getValue := (cc: *CC) -> *any{
  return LLVMBuildLoad(cc.builder, self.alloc, "ival");
}

InterfaceInstance.preOpGen := (cc: *CC, op: string) -> *Value{
  return 0;
}
InterfaceInstance.postOpGen := (cc: *CC, op: string) -> *Value{
  return 0;
}
InterfaceInstance.binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value{
  return 0;
}
InterfaceInstance.callGen := (cc: *CC, arg: *LinkedNode) -> *Value{
  return 0;
}
InterfaceInstance.assignGen := (cc: *CC, val: *Value) -> void{
  LLVMBuildStore(cc.builder, val.getValue(), self.alloc);
  return;
}
InterfaceInstance.memberGen := (cc: *CC, name: string) -> *Value{
  ind := 0;
  l: *LinkedNode = self.ic.first;
  while(l){
    m : *Member = l.p;
    if(streq(m.id, name)){
      // TODO resolve method to function pointer
      return 0;
    }
    ind = ind + 1;
    l = l.next;
  }
  // TODO raise error?
  return 0;
}
InterfaceConcept.size := (cc: *CC) -> int{
  return 0; // TODO
}
InterfaceConcept.staticMemberType := (cc: *CC, name: string) -> *Type{
  return 0;
}
InterfaceConcept.staticMemberGen := (cc: *CC, name: string) -> *Value{
  return 0;
}
InterfaceInstance.castGen := (cc: *CC, t: *Type) -> *Value{
  // TODO cast to structs
  return 0;
}

InterfaceConcept.getName := (cc: *CC) -> string{
  return strcat("interface ", self.id);
}
InterfaceConcept.getInstance := (cc: *CC, val: *any, name: string) -> *Value {
  // instantiate an interface
  i: *InterfaceInstance = malloc(sizeof InterfaceInstance);
  i.ic = self;
  i.alloc = LLVMBuildAlloca(cc.builder, self.holder, name);
  if(val) LLVMBuildStore(cc.builder, val, i.alloc);
  v: *Value = malloc(sizeof Value);
  v = i;
  return v;
}
InterfaceConcept.cast := (cc: *CC, target: *Type) -> bool{
  // Do not cast to structs, this is interface type not interface instance
  return 0;
}
InterfaceConcept.preOpType := (cc: *CC, op: string) -> *Type {return 0;}
InterfaceConcept.preOpGen := (cc: *CC, op:string) -> *Value {return 0;}
InterfaceConcept.postOpType := (cc: *CC, op: string) -> *Type {return 0;}
InterfaceConcept.postOpGen := (cc: *CC, op:string) -> *Value {return 0;}
InterfaceConcept.binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type {return 0;}
InterfaceConcept.assignGen := (cc: *CC, v: *Value) -> *Value {return 0;}
InterfaceConcept.binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value {return 0;}
InterfaceConcept.callType := (cc: *CC, args: *LinkedNode) -> *Type {return 0;}
InterfaceConcept.callGen := (cc: *CC, args: *LinkedNode) -> *Value{return 0;}
InterfaceConcept.castGen := (cc: *CC, target: *Type) -> *Value{return 0;}
InterfaceConcept.typegen := (cc: *CC) -> *any{
  return self.holder;
}
InterfaceConcept.memberType := (cc: *CC, name: string) -> *Type{
  // TODO check methods
  return 0;
}
InterfaceConcept.memberGen := (cc: *CC, name: string) -> *Value{
  // TODO check methods only
  return 0;
}
InterfaceConcept.getValue := (cc: *CC) -> *any{
  return self.holder;
}
InterfaceConcept.assignCheck := (cc: *CC, t: *Type) -> bool{
  return 0;
}
InterfaceConcept.getType := (cc: *CC) -> *Type{
  ttc: *TypeTypeConcept = malloc(sizeof TypeTypeConcept);
  ttc = self;
  tt: *TypeType = malloc(sizeof TypeType);
  tt.baseContext = ttc;
  t: *Type = malloc(sizeof Type);
  t = tt;
  return t;
}
InterfaceInstance.getType := (cc: *CC) -> *Type{
  t: *Type = malloc(sizeof Type);
  t = self.ic;
  return t;
}
InterfaceConcept.register := (cc: *CC) -> void{
  self.vptr = LLVMStructCreateNamed(cc.context, strcat(self.id, "$$"));
  self.holder = LLVMStructCreateNamed(cc.context, self.id);

  v: *Value = malloc(sizeof Value);
  v = self;
  cc.registerNamed(self.id, v);
  return;
}
InterfaceConcept.compile := (cc: *CC) -> void{
  count := 1; // classptr
  f: *LinkedNode = self.first;
  while(f){
    count = count + 1;
    f = f.next;
  }
  members: *any = malloc(sizeof *any * count);
  f = self.first;
  i := 1;
  *members = LLVMInt64TypeInContext(cc.context);
  pointer_type := LLVMPointerType(LLVMInt64TypeInContext(cc.context), 0);
  while(f){
    *(members+i) = pointer_type;
    f = f.next;
    i = i + 1;
  }
  LLVMStructSetBody(self.vptr, members, count, 0); // TODO change packed?

  members_2 : *any = malloc(sizeof *any * 2);
  *members_2 = pointer_type;
  *(members_2+1) = LLVMPointerType(self.vptr, 0);

  LLVMStructSetBody(self.holder, members_2, 2, 0); // TODO change packed?

  return;
}

InterfaceDefineParser : struct{}
InterfaceDefineParser.getName := (cc: *CC) -> string{
  return "struct";
}
InterfaceDefineParser.parse := (cc: *CC) -> *Concept{
  dbg := cc.getDBG();

  id := cc.expectId();
  if(!id) return 0;
  if(!cc.expectToken(TokenType.TCOL)) return 0;
  if(!cc.expectToken(TokenType.TINTERFACE)) return 0;
  if(!cc.expectToken(TokenType.TLCB)) return 0;

  fsignParser : FunctionSigParser;

  first :*LinkedNode = 0;
  prev: *LinkedNode = 0;
  while(!cc.expectToken(TokenType.TRCB)){
    c : *Concept = fsignParser.parse(cc);
    if(!c) return 0;
    tmp :*LinkedNode = malloc(sizeof LinkedNode);
    tmp.p = c;
    tmp.next = 0;

    if(!first) first = tmp;
    if(prev) prev.next = tmp;
    prev = tmp;
  }
  cc.expectToken(TokenType.TRCB);

  sd: *InterfaceConcept = malloc(sizeof InterfaceConcept);
  sd.dbg = dbg;
  sd.id = id;
  sd.first = first;

  sd.vptr = 0;
  sd.holder = 0;

  ctx: *Concept = malloc(sizeof Concept);
  ctx = sd;

  return ctx;
}

EnumConcept: struct{
  id: string;
  dbg: *DBG;
  first: *LinkedNode;
}
EnumConcept.getName := (cc: *CC) -> string{
  return strcat("enum ", self.id);
}
EnumConcept.typegen := (cc: *CC) -> *any{
  return LLVMInt16TypeInContext(cc.context);
}
EnumConcept.getInstance := (cc: *CC, val: *any, name: string) -> *Value {return 0;} // TODO return Int Instance
EnumConcept.preOpType := (cc: *CC, op: string) -> *Type {return 0;}
EnumConcept.preOpGen := (cc: *CC, op:string) -> *Value {return 0;}
EnumConcept.postOpType := (cc: *CC, op: string) -> *Type {return 0;}
EnumConcept.postOpGen := (cc: *CC, op:string) -> *Value {return 0;}
EnumConcept.binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type {return 0;}
EnumConcept.binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value {return 0;}
EnumConcept.callType := (cc: *CC, args: *LinkedNode) -> *Type {return 0;}
EnumConcept.callGen := (cc: *CC, args: *LinkedNode) -> *Value{return 0;}
EnumConcept.castGen := (cc: *CC, target: *Type) -> *Value{return 0;}
EnumConcept.cast := (cc: *CC, target: *Type) -> bool{ return 0; }
EnumConcept.assignGen := (cc: *CC, v: *Value) -> *Value {return 0;}
EnumConcept.memberType := (cc: *CC, name: string) -> *Type{
  // TODO check members
  return 0;
}
EnumConcept.memberGen := (cc: *CC, name: string) -> *Value{
  // TODO check memebrs
  return 0;
}
EnumConcept.staticMemberType := (cc: *CC, name: string) -> *Type{
  return 0;
}
EnumConcept.staticMemberGen := (cc: *CC, name: string) -> *Value{
  return 0;
}
EnumConcept.getValue := (cc: *CC) -> *any{ return 0; } // TODO this should return inttype64
EnumConcept.assignCheck := (cc: *CC, t: *Type) -> bool{
  return 0;
}
EnumConcept.getType := (cc: *CC)->*Type{
  ttc: *TypeTypeConcept = malloc(sizeof TypeTypeConcept);
  ttc = self;
  tt: *TypeType = malloc(sizeof TypeType);
  tt.baseContext = ttc;
  t: *Type = malloc(sizeof Type);
  t = tt;
  return t;
}
EnumConcept.register := (cc: *CC) -> void{
  v: *Value = malloc(sizeof Value);
  v = self;
  cc.registerNamed(self.id, v);

  return;
}
EnumConcept.compile := (cc: *CC) -> void{
  // Nothing to do!
  return;
}

EnumItem : struct{
  id: string;
  hasval: bool;
  val: int;
}

EnumDefineParser: struct{}
EnumDefineParser.getName := (cc: *CC) -> string{
  return "enum";
}
EnumDefineParser.parse := (cc: *CC) -> *Concept{
  dbg:= cc.getDBG();

  id := cc.expectId();
  if(!id) return 0;
  if(!cc.expectToken(TokenType.TCOL)) return 0;
  if(!cc.expectToken(TokenType.TENUM)) return 0;
  if(!cc.expectToken(TokenType.TLCB)) return 0;

  first: *LinkedNode = 0;
  prev: *LinkedNode = 0;
  while(!cc.expectToken(TokenType.TRCB)){
    mid := cc.expectId();
    val :int;
    hasval := 0;
    if(!mid) return 0;
    if(cc.expectToken(TokenType.TEQ)){
      // it has a default
      hasval = 1;
      cc.expectToken(TokenType.TEQ);
      tmp := cc.expectNum(); // This should return pointer to int
      if(!tmp) return 0;
      val = *tmp;
      // free(tmp);
    }
    i: *EnumItem = malloc(sizeof EnumItem);
    i.id = mid;
    i.hasval = hasval;
    i.val = val;

    tmp : *LinkedNode = malloc(sizeof LinkedNode);
    tmp.p = i;
    tmp.next = 0;

    if(!first) first = tmp;
    if(prev) prev.next = tmp;
    prev = tmp;
  }
  cc.expectToken(TokenType.TRCB);

  ed : *EnumConcept = malloc(sizeof EnumConcept);
  ed.dbg = dbg;
  ed.id = id;
  ed.first = first;

  ctx: *Concept = malloc(sizeof Concept);
  ctx = ed;

  return ctx;
}

MethodDefineParser: struct{}
MethodDefineParser.getName := (cc: *CC) -> string{
  return "method";
}
MethodDefineParser.parse := (cc: *CC) -> *Concept{
  className := cc.expectId();
  if(!className) return 0;
  if(!cc.expectToken(TokenType.TDOT)) return 0;
  fparse: FunctionDefineParser;
  c :*Concept= fparse.parse(cc);
  if(!c) return 0;
  fd: *FunctionConcept;
  fd = c; // extract it

  // change the name and add a first argument
  fd.id = strcat(className, strcat("$", fd.id));

  selfarg : *BasicArg = malloc(sizeof BasicArg);
  base := cc.resolveNamed(className);

  if(!(base instanceof StructConcept)){
    cc.setError("Methods can be defined on structs only.");
    return 0;
  }
  selfarg.type = base;
  selfarg.id = "self";
  selfarg.isvararg = 0;

  selfargholder: *Arg = malloc(sizeof Arg);
  selfargholder = selfarg;

  // register it with the original struct
  sc: *StructConcept = base;
  mln : *LinkedNode = malloc(sizeof LinkedNode);
  mln.next = sc.firstMethod;
  mln.p = c;
  sc.firstMethod = mln;

  lc: *LinkedNode = malloc(sizeof LinkedNode);
  lc.p = selfargholder;
  lc.next = fd.type.args;

  fd.type.args = lc;

  return c;
}

IfStatement: struct{
  dbg: *DBG;
  exp: *Value;
  st1: *Statement;
  st2: *Statement;
}

is_br_ok := (cc: *CC) -> bool{
  instr := LLVMGetBasicBlockTerminator(LLVMGetInsertBlock(cc.builder));
  if(instr == 0){ // if there aren't any instruction, it's okay
    return 1;
  }
  opcode := LLVMGetInstructionOpcode(instr);
  if(opcode == 0){// ret
    return 0;
  }
  if(opcode == 1){// br
    return 0;
  }
  return 1;
}
IfStatement.getName := (cc: *CC) -> string{
  return "if";
}
IfStatement.codegen := (cc: *CC) -> void{
  f := LLVMGetBasicBlockParent(LLVMGetInsertBlock(cc.builder));

  ifB := LLVMAppendBasicBlockInContext(cc.context, f, "if");
  elseB :*any;
  mergeB := LLVMCreateBasicBlockInContext(cc.context, "ifcont");
  if(self.st2){// we have else
    elseB = LLVMCreateBasicBlockInContext(cc.context, "else");
  } else {
    elseB = mergeB;
  }

  cond := self.exp.getValue(cc);

  correct_type : bool = LLVMTypeOf(cond) == LLVMInt64TypeInContext(cc.context);
  if(!correct_type){
    cond = LLVMBuildIntCast2(cc.builder, cond, LLVMInt64TypeInContext(cc.context), 1, "cond");
  }

  cond = LLVMBuildICmp(cc.builder, 33, cond, LLVMConstInt(LLVMInt64TypeInContext(cc.context), 0, 0), "ifcond");

  LLVMBuildCondBr(cc.builder, cond, ifB, elseB);

  cc.pushBlock();
  LLVMPositionBuilder(cc.builder, ifB, 0);
  self.st1.codegen(cc);
  if(is_br_ok(cc)){
    LLVMBuildBr(cc.builder, mergeB);
  }
  cc.popBlock();

  if(self.st2){
    cc.pushBlock();
    LLVMAppendExistingBasicBlock(f, elseB);
    LLVMPositionBuilder(cc.builder, elseB, 0);
    self.st2.codegen(cc);
    if(is_br_ok(cc)){
      LLVMBuildBr(cc.builder, mergeB);
    }
    cc.popBlock();
  }

  LLVMAppendExistingBasicBlock(f, mergeB);
  LLVMPositionBuilder(cc.builder, mergeB, 0);

  return;
}

IfStmtParser: struct{}
IfStmtParser.getName := (cc: *CC) -> string{
  return "if";
}
IfStmtParser.parse := (cc: *CC) -> *Statement{
  dbg := cc.getDBG();
  if(!cc.expectToken(TokenType.TIF)) return 0; // if
  if(!cc.expectToken(TokenType.TLPAR)) return 0; // (
  exp := cc.expectExpression(); // exp
  if(!exp) return 0;
  if(!cc.expectToken(TokenType.TRPAR)) return 0; // )
  st1 := cc.expectStatement();
  if(!st1) return 0;
  st2: *Statement = 0;
  if(cc.expectToken(TokenType.TELSE)){  // else
    st2 = cc.expectStatement();
    if(!st2) return 0;
  }
  // ===
  ifs : *IfStatement = malloc(sizeof IfStmtParser);
  ifs.dbg = dbg;
  ifs.exp = exp;
  ifs.st1 = st1;
  ifs.st2 = st2;

  stmt: *Statement = malloc(sizeof Statement);
  stmt = ifs;
  return stmt;
}

WhileStatement: struct{
  dbg: *DBG;
  exp: *Value;
  st: *Statement;
}
WhileStatement.getName := (cc: *CC) -> string{
  return "while";
}
WhileStatement.codegen := (cc: *CC) -> void{
  f := LLVMGetBasicBlockParent(LLVMGetInsertBlock(cc.builder));

  condB := LLVMAppendBasicBlockInContext(cc.context, f, "whilecond");
  whileB := LLVMAppendBasicBlockInContext(cc.context, f, "while");
  mergeB := LLVMCreateBasicBlockInContext(cc.context, "whilecont");

  LLVMBuildBr(cc.builder, condB);
  LLVMPositionBuilder(cc.builder, condB, 0);

  cond := self.exp.getValue(cc);

  correct_type : bool = LLVMTypeOf(cond) == LLVMInt64TypeInContext(cc.context);
  if(correct_type == 0){
    cond = LLVMBuildIntCast2(cc.builder, cond, LLVMInt64TypeInContext(cc.context), 1, "cond");
  }

  cond = LLVMBuildICmp(cc.builder, 33, cond, LLVMConstInt(LLVMInt64TypeInContext(cc.context), 0, 0), "whilecond");

  LLVMBuildCondBr(cc.builder, cond, whileB, mergeB);

  cc.pushBlock();
  LLVMPositionBuilder(cc.builder, whileB, 0);
  self.st.codegen(cc);
  if(is_br_ok(cc)){
    LLVMBuildBr(cc.builder, condB);
  }
  cc.popBlock();

  LLVMAppendExistingBasicBlock(f, mergeB);
  LLVMPositionBuilder(cc.builder, mergeB, 0);

  return ;
}

WhileStmtParser: struct{}
WhileStmtParser.getName := (cc: *CC) -> string{
  return "while";
}
WhileStmtParser.parse := (cc: *CC) -> *Statement{
  dbg := cc.getDBG();
  if(!cc.expectToken(TokenType.TWHILE)) return 0;
  if(!cc.expectToken(TokenType.TLPAR)) return 0;
  exp := cc.expectExpression();
  if(!exp) return 0;
  if(!cc.expectToken(TokenType.TRPAR)) return 0;
  st := cc.expectStatement();
  if(!st) return 0;
  // ====
  ws : *WhileStatement = malloc(sizeof WhileStatement);
  ws.dbg = dbg;
  ws.exp = exp;
  ws.st = st;

  stmt: *Statement = malloc(sizeof Statement);
  stmt = ws;
  return stmt;
}

assignBase := (cc: *CC, base: *Value, val: *Value)->void{
  tb := base.getType(cc);
  tv := val.getType(cc);
  if(tb.assignCheck(cc, tv)){
    base.assignGen(val);
    return;
  }
  if(tv.cast(cc, tb)){
    v := val.castGen(cc, tb());
    base.assignGen(v);
  }
  // TODO improve error reporting
  printf("Error in assignBase\n");
  exit(1);
  return;
}

AssignStatement: struct{
  dbg: *DBG;
  base: *Value;
  val: *Value;
}
AssignStatement.getName := (cc: *CC) -> string{
  return "assignment";
}
AssignStatement.codegen := (cc: *CC) -> void{
  assignBase(cc, self.base, self.val);
  return ;
}

AssignStmtParser: struct{}
AssignStmtParser.getName := (cc: *CC) -> string{
  return "assignment";
}
AssignStmtParser.parse := (cc: *CC) -> *Statement{
  dbg := cc.getDBG();
  base := cc.expectExpression();
  if(!base) return 0;
  if(!cc.expectToken(TokenType.TEQ)) return 0;
  exp := cc.expectExpression();
  if(!exp) return 0;
  if(!cc.expectToken(TokenType.TSEM)) return 0;
  // ====
  ast: *AssignStatement = malloc(sizeof AssignStatement);
  ast.base = base;
  ast.dbg = dbg;
  ast.val = exp;

  stmt: *Statement = malloc(sizeof Statement);
  stmt = ast;
  return stmt;
}

ReturnStatement: struct{
  dbg: *DBG;
  exp: *Value;
}
ReturnStatement.getName := (cc: *CC) -> string{
  return "return";
}
ReturnStatement.codegen := (cc: *CC) -> void{
  if(self.exp){// has value
    LLVMBuildRet(cc.builder, self.exp.getValue(cc));
  } else {
    LLVMBuildRetVoid(cc.builder);
  }
  return;
}

ReturnStmtParser: struct{}
ReturnStmtParser.getName := (cc: *CC) -> string{
  return "return";
}
ReturnStmtParser.parse := (cc: *CC) -> *Statement{
  dbg := cc.getDBG();
  if(!cc.expectToken(TokenType.TRET)) return 0;
  exp := cc.expectExpression();
  if(!cc.expectToken(TokenType.TSEM)) return 0;
  // ====
  rst: *ReturnStatement = malloc(sizeof ReturnStatement);
  rst.exp = exp;
  rst.dbg = dbg;

  stmt: *Statement = malloc(sizeof Statement);
  stmt = rst;
  return stmt;
}

ExpressionStatement: struct{
  dbg: *DBG;
  exp: *Value;
}
ExpressionStatement.getName := (cc: *CC) -> string{
  return "expression";
}
ExpressionStatement.codegen := (cc: *CC) -> void{
  self.exp.getValue();
  return;
}

ExpressionStmtParser: struct{}
ExpressionStmtParser.getName := (cc: *CC) -> string{
  return "expression";
}
ExpressionStmtParser.parse := (cc: *CC) -> *Statement{
  dbg := cc.getDBG();
  exp := cc.expectExpression();
  if(!exp) return 0;
  if(!cc.expectToken(TokenType.TSEM)) return 0;
  // ====
  est: *ExpressionStatement = malloc(sizeof ExpressionStatement);
  est.exp = exp;
  est.dbg = dbg;

  stmt: *Statement = malloc(sizeof Statement);
  stmt = est;
  return stmt;
}

DefineStatement: struct{
  dbg: *DBG;
  id: string;
  type: *Type;
  exp: *Value;
}
DefineStatement.getName := (cc: *CC) -> string{
  return strcat("define ", self.id);
}
DefineStatement.codegen := (cc: *CC) -> void{
  // resolve type
  if(!self.type) self.type = self.exp.getType(cc);

  // create instance
  val: *any = 0;
  if(self.exp) val = self.exp.getValue(cc);
  inst := self.type.getInstance(cc, val, self.id);

  // register cc
  cc.registerNamed(self.id, inst);
  return ;
}

DefineStmtParser: struct{}
DefineStmtParser.getName := (cc: *CC) -> string{
  return "define";
}
DefineStmtParser.parse := (cc: *CC) -> *Statement{
  dbg := cc.getDBG();
  id := cc.expectId();
  if(!id) return 0;
  type :*Type = 0;
  exp :*Value = 0;
  if(cc.expectToken(TokenType.TDEF)){
    exp = cc.expectExpression();
  } else if(cc.expectToken(TokenType.TCOL)){
    type = cc.expectType();
    if(!type) return 0;
    if(cc.expectToken(TokenType.TEQ)){
      exp = cc.expectExpression();
      if(!exp) return 0;
    }
  } else return 0;
  if(!cc.expectToken(TokenType.TSEM)) return 0;
  // ===
  dst: *DefineStatement = malloc(sizeof DefineStatement);
  dst.id = id;
  dst.type = type;
  dst.exp = exp;
  dst.dbg = dbg;

  stmt: *Statement = malloc(sizeof Statement);
  stmt = dst;
  return stmt;
}

CodeBlockStatement: struct{
  dbg: *DBG;
  first: *LinkedNode; // of Statement
}
CodeBlockStatement.getName := (cc: *CC) -> string{
  return "code block";
}
CodeBlockStatement.codegen := (cc: *CC) -> void {
  cc.pushBlock();
  stmt := self.first;
  while(stmt){
    s: *Statement = stmt.p;
    s.codegen(cc);

    stmt = stmt.next;
  }
  cc.popBlock();
  return;
}

CodeBlockParser: struct{}
CodeBlockParser.getName := (cc: *CC) -> string{
  return "code block";
}
CodeBlockParser.parse := (cc: *CC) -> *Statement{
  dbg := cc.getDBG();
  if(!cc.expectToken(TokenType.TLCB)) return 0;
  first: *LinkedNode = 0;
  c: *LinkedNode = 0;
  while(!cc.expectToken(TokenType.TRCB)){
    tmp := cc.expectStatement();
    if(!tmp) return 0;

    ltmp: *LinkedNode = malloc(sizeof LinkedNode);
    ltmp.p = tmp;
    ltmp.next = 0;

    if(!first) first = ltmp;
    if(c) c.next = ltmp;
    c = ltmp;
  }

  cb: *CodeBlockStatement = malloc(sizeof CodeBlockStatement);
  cb.first = first;
  cb.dbg = dbg;

  stmt: *Statement = malloc(sizeof Statement);
  stmt = cb;
  return stmt;
}

IntType: struct{
  dbg: *DBG;
  size: int;
  signed: int;
}

IntInstance: struct{
  type: *IntType;
  alloc: *any;
}

IntInstance.getType := (cc: *CC) -> *Type{ return 0;} // Forward declaration!
IntInstance.getValue := (cc: *CC) -> *any{
  return LLVMBuildLoad(cc.builder, self.alloc, "intval");
}
IntInstance.assignGen := (cc: *CC, val: *Value) -> void{
  LLVMBuildStore(cc.builder, val.getValue(cc), self.alloc);
  return;
}
IntInstance.preOpGen := (cc: *CC, op: string) -> *Value{return 0;}
IntInstance.postOpGen := (cc: *CC, op: string) -> *Value{return 0;}
IntInstance.binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value{
  // TODO
  return 0;
}
IntInstance.callGen := (cc: *CC, args: *LinkedNode) -> *Value{return 0;}
IntInstance.memberGen := (cc: *CC, name: string) -> *Value{return 0;}
IntInstance.castGen := (cc: *CC, target: *Type) -> *Value{
  // TODO!
  return 0;
}

IntType.size := (cc: *CC) -> int{
  return 0; // TODO
}
IntType.getName := (cc: *CC) -> string{
  if(self.size == 1) return "bool";
  base: string;
  if(self.signed) base = "signed";
  else base = "unsigned";

  rest: string;
  s := self.size;
  if(s == 0) rest = "";
  if(s == 8) rest = " 8";
  if(s == 16) rest = " 16";
  if(s == 32) rest = " 32";
  if(s == 64) rest = " 64";

  return strcat(base, strcat(" int", rest));
}
IntType.typegen := (cc: *CC) -> *any{
  if(self.size == 0)
    return LLVMInt64TypeInContext(cc.context);
  else if(self.size == 1)
    return LLVMInt1TypeInContext(cc.context);
  else if(self.size == 8)
    return LLVMInt8TypeInContext(cc.context);
  else if(self.size == 16)
    return LLVMInt16TypeInContext(cc.context);
  else if(self.size == 32)
    return LLVMInt32TypeInContext(cc.context);
  else if(self.size == 64)
    return LLVMInt64TypeInContext(cc.context);
  printf("Unknown int size %d\n", self.size);
  self.dbg.printAndExit();
  return 0;
}
IntType.getInstance := (cc: *CC, val: *any, name: string) -> *Value{
  ii: *IntInstance = malloc(sizeof IntInstance);
  ii.type = self;
  ii.alloc = LLVMBuildAlloca(cc.builder, self.typegen(cc), name);
  if(val) LLVMBuildStore(cc.builder, val, ii.alloc);
  v: *Value = malloc(sizeof Value);
  v = ii;
  return v;
}
IntType.preOpType := (cc: *CC, op: string) -> *Type{return 0;}
IntType.postOpType := (cc: *CC, op: string) -> *Type{return 0;}
IntType.binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type{return 0;}
IntType.callType := (cc: *CC, args: *LinkedNode) -> *Type{return 0;}
IntType.memberType := (cc: *CC, name: string) -> *Type{return 0;}

IntType.assignCheck := (cc: *CC, t: *Type) -> bool{return;} // Forward declaration
IntType.cast := (cc: *CC, target: *Type) -> bool{ return;} // Forward declaration

IntInstance.getType := (cc: *CC) -> *Type{
  t: *Type = malloc(sizeof Type);
  t = self.type;
  return t;
}

PointerType: struct{
  dbg: *DBG;
  base: *Type;
}
PointerInstance: struct{
  alloc: *any;
  type: *PointerType;
}

PointerInstance.getType := (cc: *CC) -> *Type{return 0;} // forward declaration
PointerInstance.getValue := (cc: *CC) -> *any{
  return LLVMBuildLoad(cc.builder, self.alloc, "intval");
}
PointerInstance.assignGen := (cc: *CC, val: *Value) -> void{
  LLVMBuildStore(cc.builder, val.getValue(cc), self.alloc);
  return;
}
PointerInstance.preOpGen := (cc: *CC, op: string) -> *Value{return 0;} // TODO
PointerInstance.postOpGen := (cc: *CC, op: string) -> *Value{return 0;}
PointerInstance.binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value{return 0;} // TODO
PointerInstance.callGen := (cc: *CC, args: *LinkedNode) -> *Value{return 0;} // TODO
PointerInstance.memberGen := (cc: *CC, name: string) -> *Value{return 0;} // TODO
PointerInstance.castGen := (cc: *CC, target: *Type) -> *Value{
  // TODO!
  return 0;
}

PointerType.callType := (cc: *CC, args: *LinkedNode) -> *Type{
  return self.base.callType(cc, args);
}
PointerType.memberType := (cc: *CC, name: string) -> *Type{
  return self.base.memberType(cc, name);
}
PointerType.size := (cc: *CC) -> int{
  return 0; // TODO
}
PointerType.getName := (cc: *CC) -> string{
  return strcat("*", self.base.getName(cc));
}
PointerType.typegen := (cc: *CC) -> *any{
  return LLVMPointerType(self.base.typegen(cc), 0);
}
PointerType.getInstance := (cc: *CC, val: *any, name: string) -> *Value{
  pi: *PointerInstance = malloc(sizeof PointerInstance);
  pi.alloc = LLVMBuildAlloca(cc.builder, self.typegen(cc), name);
  pi.type = self;
  if(val) LLVMBuildStore(cc.builder, val, pi.alloc);
  v: *Value = malloc(sizeof Value);
  v = pi;
  return v;
}
PointerType.cast := (cc: *CC, target: *Type) -> bool{
  // TODO
}
PointerType.assignCheck := (cc: *CC, t: Type) -> bool{
  // TODO
}
PointerType.preOpType := (cc: *CC, op: string) -> *Type{
  if(streq(op, "*")){
    t: *Type = malloc(sizeof Type);
    t = self.base;
    return t;
  }
  return 0;
}
PointerType.postOpType := (cc: *CC, op: string) -> *Type{return 0;}
PointerType.binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type{
  // handle pointer arithmetics
  if(streq(op, "+")){
    if(rhs instanceof IntType){
      t: *Type = malloc(sizeof Type);
      t = self;
      return t;
    }
  }
  if(streq(op, "-")){
    if(rhs instanceof IntType){
      t: *Type = malloc(sizeof Type);
      t = self;
      return t;
    }
  }
  return 0;
}
IntType.cast := (cc: *CC, target: *Type) -> bool{
  if(target instanceof IntType) return 1;
  if(target instanceof PointerType) return 1;
  return 0;
}
IntType.assignCheck := (cc: *CC, t: *Type) -> bool{
  if(t instanceof IntType) return 1;
  return 0;
}

IntTypeParser: struct{}
IntTypeParser.getName := (cc: *CC) -> string{
  return "int";
}
IntTypeParser.parse := (cc: *CC) -> *Type{
  dbg := cc.getDBG();
  size := 0;
  if(cc.expectToken(TokenType.TBOOL)) size = 1;
  else if(cc.expectToken(TokenType.TU8)) size = 8;
  else if(cc.expectToken(TokenType.TU16)) size = 16;
  else if(cc.expectToken(TokenType.TU32)) size = 32;
  else if(cc.expectToken(TokenType.TU64)) size = 64;
  else if(cc.expectToken(TokenType.TS8)) size = 0-8;
  else if(cc.expectToken(TokenType.TS16)) size = 0-16;
  else if(cc.expectToken(TokenType.TS32)) size = 0-32;
  else if(cc.expectToken(TokenType.TS64)) size = 0-64;
  else if(cc.expectToken(TokenType.TINT)) size = 0;
  else return 0;

  signed := 0;
  if(size < 1){ // to include 0 for int
    signed = 1;
    size = size * (0-1);
  }

  itp: *IntType = malloc(sizeof IntType);
  itp.size = size;
  itp.signed = signed;
  itp.dbg = dbg;

  t: *Type = malloc(sizeof Type);
  t = itp;
  return t;
}


PointerInstance.getType := (cc: *CC) -> *Type{
  t: *Type = malloc(sizeof Type);
  t = self.type;
  return t;
}

PtrTypeParser: struct{}
PtrTypeParser.getName := (cc: *CC) -> string{
  return "pointer";
}
PtrTypeParser.parse := (cc: *CC) -> *Type{
  dbg := cc.getDBG();
  if(!cc.expectToken(TokenType.TSTAR)) return 0;
  base := cc.expectType();
  if(!base) return 0;
  // ====
  ftp: *PointerType = malloc(sizeof PointerType);
  ftp.dbg = dbg;
  ftp.base = base;

  t: *Type = malloc(sizeof Type);
  t = ftp;
  return t;
}

StrTypeParser: struct{}
StrTypeParser.getName := (cc: *CC) -> string{
  return "string";
}
StrTypeParser.parse := (cc: *CC) -> *Type{
  dbg := cc.getDBG();
  if(!cc.expectToken(TokenType.TSTR)) return 0;
  // ===
  bu: *IntType = malloc(sizeof IntType);
  bu.size = 8;
  bu.signed = 0;

  base : *Type = malloc(sizeof Type);
  base = bu;
  
  ftp: *PointerType = malloc(sizeof PointerType);
  ftp.dbg = dbg;
  ftp.base = base;

  t: *Type = malloc(sizeof Type);
  t = ftp;
  return t;
}

AnyTypeParser: struct{}
AnyTypeParser.getName := (cc: *CC) -> string{
  return "any";
}
AnyTypeParser.parse := (cc: *CC) -> *Type{
  dbg := cc.getDBG();
  if(!cc.expectToken(TokenType.TANY)) return 0;
  // ===
  bu: *IntType = malloc(sizeof IntType);
  bu.size = 8;
  bu.signed = 0;

  base : *Type = malloc(sizeof Type);
  base = bu;
  
  ftp: *PointerType = malloc(sizeof PointerType);
  ftp.dbg = dbg;
  ftp.base = base;

  t: *Type = malloc(sizeof Type);
  t = ftp;
  return t;
}

VoidValue: struct{
  t: *Type;
}
VoidValue.getType := (cc: *CC) -> *Type{return self.t;}
VoidValue.getValue := (cc: *CC) -> *any{return 0;}
VoidValue.assignGen := (cc: *CC, val: *Value) -> void{return;}
VoidValue.preOpGen := (cc: *CC, op: string) -> *Value{return 0;}
VoidValue.postOpGen := (cc: *CC, op: string) -> *Value{return 0;}
VoidValue.binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value{return 0;}
VoidValue.callGen := (cc: *CC, args: *LinkedNode) -> *Value{return 0;}
VoidValue.memberGen := (cc: *CC, name: string) -> *Value{return 0;}
VoidValue.castGen := (cc: *CC, target: *Type) -> *Value{return 0;}

VoidType: struct{
  dbg: *DBG;
}
VoidType.size := (cc: *CC) -> int{ return 0; } // TODO
VoidType.getName := (cc: *CC) -> string{
  return "void";
}
VoidType.typegen := (cc: *CC) -> *any{
  return LLVMVoidTypeInContext(cc.context);
}
VoidType.cast := (cc: *CC, target: *Type) -> bool{ return 0; }
VoidType.assignCheck := (cc: *CC, target: *Type) -> *Type { return 0; }
VoidType.preOpType := (cc: *CC, op: string) -> *Type { return 0; }
VoidType.postOpType := (cc: *CC, op: string) -> *Type { return 0; }
VoidType.binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type { return 0; }
VoidType.callType := (cc: *CC, args: *LinkedNode) -> *Type { return 0; }
VoidType.memberType := (cc: *CC, name: string) -> *Type { return 0; }
VoidType.getInstance := (cc: *CC, val: *any, name: string) -> *Value{
  t: *Type = malloc(sizeof Type);
  t = self;
  vv: *VoidValue = malloc(sizeof VoidValue);
  vv.t = t;
  v: *Value = malloc(sizeof Value);
  v = vv;
  return v;
}

VoidTypeParser: struct{}
VoidTypeParser.getName := (cc: *CC) -> string{
  return "void";
}
VoidTypeParser.parse := (cc: *CC) -> *Type{
  dbg := cc.getDBG();
  if(!cc.expectToken(TokenType.TVOID)) return 0;
  // ===
  vt: *VoidType = malloc(sizeof VoidType);
  vt.dbg = dbg;

  t: *Type = malloc(sizeof Type);
  t = vt;
  return t;
}

FloatType: struct{
  dbg: *DBG;
  size: int;
}
FloatInstance: struct{
  alloc: *any;
  type: *FloatType;
}

FloatType.size := (cc: *CC) -> int{ return 0; } // TODO
FloatInstance.getType := (cc: *CC) -> *Type {return 0;} // Forward Declaration
FloatInstance.getValue := (cc: *CC) -> *any{
  return LLVMBuildLoad(cc.builder, self.alloc, "fval");
}
FloatInstance.assignGen := (cc: *CC, val: *Value) -> *Value{
  LLVMBuildStore(cc.builder, val.getValue(cc), self.alloc);
  return 0;
}
FloatInstance.preOpGen := (cc: *CC, op: string) -> *Value{return 0;}
FloatInstance.postOpGen := (cc: *CC, op: string) -> *Value{return 0;}
FloatInstance.binOpGen := (cc: *CC, op: string, rhs: *Value) -> *Value{return 0;}
FloatInstance.callGen := (cc: *CC, args: *LinkedNode) -> *Value{return 0;}
FloatInstance.memberGen := (cc: *CC, name: string) -> *Value{return 0;}
FloatInstance.castGen := (cc: *CC, target: *Type) -> *Value{
  return 0;
}

FloatType.getName := (cc: *CC) -> string{
  if(self.size == 32) return "f32";
  return "f64";
}
FloatType.typegen := (cc: *CC) -> *any{
  if(self.size == 32) return LLVMFloatTypeInContext(cc.context);

  return LLVMDoubleTypeInContext(cc.context);
}
FloatType.getInstance := (cc: *CC, val: *any, name: string) -> *Value{
  fi: *FloatInstance = malloc(sizeof FloatInstance);
  fi.type = self;
  fi.alloc = LLVMBuildAlloca(cc.builder, self.typegen(cc), name);
  if(val) LLVMBuildStore(cc.builder, val, fi.alloc);
  v: *Value = malloc(sizeof Value);
  v = fi;
  return v;
}
FloatType.cast := (cc: *CC, target: *Type) -> bool{
  // TODO
}
FloatType.assignCheck := (cc: *CC, t: *Type) -> bool{
  // TODO
  return 0;
}
FloatType.preOpType := (cc: *CC, op: string) -> *Type{return 0;}
FloatType.postOpType := (cc: *CC, op: string) -> *Type{return 0;}
FloatType.binOpType := (cc: *CC, op: string, rhs: *Type) -> *Type{return 0;}
FloatType.callType := (cc: *CC, args: *LinkedNode) -> *Type{return 0;}
FloatType.memberType := (cc: *CC, name: string) -> *Type{return 0;}


FloatInstance.getType := (cc: *CC) -> *Type {
  t: *Type = malloc(sizeof Type);
  t = self.type;
  return t;
}

FloatTypeParser: struct{}
FloatTypeParser.getName := (cc: *CC) -> string{
  return "float";
}
FloatTypeParser.parse := (cc: *CC) -> *Type{
  dbg := cc.getDBG();
  size := 0;
  if(cc.expectToken(TokenType.TF32)) size = 32;
  else if(cc.expectToken(TokenType.TF64)) size = 64;
  else return 0;
  // ====
  ft: *FloatType = malloc(sizeof FloatType);
  ft.dbg = dbg;
  ft.size = size;

  t: *Type = malloc(sizeof Type);
  t = ft;
  return t;
}

AnonArg: struct{
  type: *Type;
  isvararg: bool;
}
AnonArg.getName := (cc: *CC) -> string{
  return "anonArg";
}
AnonArg.codegen := (cc: *CC, val: *any) -> void{
  printf("WARNING, running codegen on anonarg");
  return;
}
AnonArg.typeresolve := (cc: *CC) -> *Type{
  return self.type;
}
AnonArg.isVarArg := (cc: *CC) -> bool{
  return self.isvararg;
}

FTypeParser: struct{}
FTypeParser.getName := (cc: *CC) -> string{
  return "function type";
}
FTypeParser.parse := (cc: *CC) -> *Type{
  dbg := cc.getDBG();
  if(!cc.expectToken(TokenType.TLPAR)) return 0;
  whilecond := !cc.expectToken(TokenType.TRPAR);

  first: *LinkedNode = 0;
  last:  *LinkedNode = 0;

  while(whilecond){
    isvararg := cc.expectToken(TokenType.T3DOT);
    t := cc.expectType();
    if(!t) return 0;
    aa: *AnonArg = malloc(sizeof AnonArg);
    aa.type = t;
    aa.isvararg = isvararg;

    a: *Arg = malloc(sizeof Arg);
    a = aa;

    tl: *LinkedNode = malloc(sizeof LinkedNode);
    tl.next = 0;
    tl.p = a;
    if(!first) first = tl;
    if(last) last.next = tl;
    last = tl;

    if(!cc.expectToken(TokenType.TCOMMA)){
      if(!cc.expectToken(TokenType.TRPAR)) return 0;
      whilecond = 0;
    }
  }
  if(!cc.expectToken(TokenType.TARROW)) return 0;
  rtype := cc.expectType();
  // ===
  fbptr: *FunctionType = malloc(sizeof FunctionType);
  fbptr.args = first;
  fbptr.returnType = rtype;
  fbptr.dbg = dbg;

  base: *Type = malloc(sizeof Type);
  base = fbptr;

  fptr: *PointerType = malloc(sizeof PointerType);
  fptr.dbg = dbg;
  fptr.base = base;

  t: *Type = malloc(sizeof Type);
  t = fptr;
  return t;
}

get_def_cc := () -> *CC{
  cc: *CC = malloc(sizeof CC);
  cc.init();

  // register consept parsers, etc
  fsp: *FunctionSigParser = malloc(sizeof FunctionSigParser);
  cp: *CParser = malloc(sizeof CParser);
  cp = fsp;
  cc.registerCP(cp);

  fdp: *FunctionDefineParser = malloc(sizeof FunctionDefineParser);
  cp: *CParser = malloc(sizeof CParser);
  cp = fdp;
  cc.registerCP(cp);

  sdp: *StructDefineParser = malloc(sizeof StructDefineParser);
  cp: *CParser = malloc(sizeof CParser);
  cp = sdp;
  cc.registerCP(cp);

  idp : *InterfaceDefineParser = malloc(sizeof InterfaceDefineParser);
  cp: *CParser = malloc(sizeof CParser);
  cp = idp;
  cc.registerCP(cp);

  edp : *EnumDefineParser = malloc(sizeof EnumDefineParser);
  cp: *CParser = malloc(sizeof CParser);
  cp = edp;
  cc.registerCP(cp);

  mdp : *MethodDefineParser = malloc(sizeof MethodDefineParser);
  cp: *CParser = malloc(sizeof CParser);
  cp = mdp;
  cc.registerCP(cp);

  // Statements
  isp: *IfStmtParser = malloc(sizeof IfStmtParser);
  sp: *SParser = malloc(sizeof SParser);
  sp = isp;
  cc.registerSP(sp);

  wsp: *WhileStmtParser = malloc(sizeof WhileStmtParser);
  sp: *SParser = malloc(sizeof SParser);
  sp = wsp;
  cc.registerSP(sp);

  asp: *AssignStmtParser = malloc(sizeof AssignStmtParser);
  sp: *SParser = malloc(sizeof SParser);
  sp = asp;
  cc.registerSP(sp);

  rsp: *ReturnStmtParser = malloc(sizeof ReturnStmtParser);
  sp: *SParser = malloc(sizeof SParser);
  sp = rsp;
  cc.registerSP(sp);

  esp: *ExpressionStmtParser = malloc(sizeof ExpressionStmtParser);
  sp: *SParser = malloc(sizeof SParser);
  sp = esp;
  cc.registerSP(sp);

  dsp: *DefineStmtParser = malloc(sizeof DefineStmtParser);
  sp: *SParser = malloc(sizeof SParser);
  sp = dsp;
  cc.registerSP(sp);

  cbp: *CodeBlockParser = malloc(sizeof CodeBlockParser);
  sp: *SParser = malloc(sizeof SParser);
  sp = cbp;
  cc.registerSP(sp);

  // Types

  itp: *IntTypeParser = malloc(sizeof IntTypeParser);
  tp: *TParser = malloc(sizeof TParser);
  tp = itp;
  cc.registerTP(tp);

  ftp: *PtrTypeParser = malloc(sizeof PtrTypeParser);
  tp: *TParser = malloc(sizeof TParser);
  tp = ftp;
  cc.registerTP(tp);

  stp: *StrTypeParser = malloc(sizeof StrTypeParser);
  tp: *TParser = malloc(sizeof TParser);
  tp = stp;
  cc.registerTP(tp);

  atp: *AnyTypeParser = malloc(sizeof AnyTypeParser);
  tp: *TParser = malloc(sizeof TParser);
  tp = atp;
  cc.registerTP(tp);

  vtp: *VoidTypeParser = malloc(sizeof VoidTypeParser);
  tp: *TParser = malloc(sizeof TParser);
  tp = vtp;
  cc.registerTP(tp);

  ftp: *FloatTypeParser = malloc(sizeof FloatTypeParser);
  tp: *TParser = malloc(sizeof TParser);
  tp = ftp;
  cc.registerTP(tp);

  ftp: *FTypeParser = malloc(sizeof FTypeParser);
  tp: *TParser = malloc(sizeof TParser);
  tp = ftp;
  cc.registerTP(tp);

  return cc;
}

CC.expectConcept := () -> *Concept{
  cp := self.cp;
  checkPoint := self.storeLexer();
  err : string = strcat("", ""); // just so it's dynamic
  while(cp){
    p: *CParser = cp.p;
    out := p.parse(self);
    if(out){
      free(err);
      return out;
    }
    e := self.lastErr;
    err = strcat(err, strcat("\n", e));
    self.restoreLexer(checkPoint);
    cp = cp.next;
  }
  self.setError(err);
  return 0;
}

CC.parse := () -> *LinkedNode{
  first: *LinkedNode = 0;
  prev: *LinkedNode = 0;

  self.skipWS();
  while(!self.isEOF()){
    c := self.expectConcept();
    if(!c){
      printf("ERROR:\n\n%s\n", self.lastErr);
      exit(1);
    }
    c.register();
    l: *LinkedNode = malloc(sizeof LinkedNode);
    l.p = c;
    l.next = 0;
    if(!first) first = l;
    if(prev) prev.next = l;
    prev = l;

    self.skipWS();
  }

  return first;
}

CC.compile := () -> void{

  self.context = LLVMContextCreate();
  self.module = LLVMModuleCreateWithNameInContext("module", self.context);
  self.builder = LLVMCreateBuilderInContext(self.context);

  LLVMSetTarget(self.module, "x86_64-pc-linux-gnu");
  LLVMSetDataLayout(self.module, "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128");

  first : *LinkedNode = self.parse();

  l := first;
  while(l){
    c: *Concept = l.p;
    c.compile();
    l = l.next;
  }

  return;
}

main := (argc: s32, argv: *string) -> int{
  if(argc != 2){
    printf("Need exactly one argument, file name\n");
    return 1;
  }

  filename := *(argv+1);

  buf: string = 0;
  f := fopen(filename, "r");

  if(!f){
    printf("Couldn't open file\n");
  }

  if(fseek(f, 0, 2)){
    printf("Unable to seek file\n");
    return 1;
  }

  bufsize := ftell(f);
  negOne := 0 - 1; // TOOD negative numbers?

  if(bufsize == negOne){
    printf("Unable to read file\n");
    return 1;
  }
  buf = malloc(sizeof u8 * (bufsize+1));

  if(fseek(f, 0, 0)){
    printf("Unable to seek file\n");
    return 1;
  }

  newLen := fread(buf, 1, bufsize, f);

  // just to be safe
  {
    tmpB: *u8 = *buf;
    tmpB = tmpB + newLen +1;
    *tmpB = 0;
  }

  cc :=  get_def_cc();
  cc.buf = buf;

  cc.compile();

  printf("%s\n", LLVMPrintModuleToString(cc.module));
  CompileLLVM(cc.module, "out.o");

  return 0;
}