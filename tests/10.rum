
printf := (T: string, s: ...any)->void;

aggregate := (A: int[], count: int, f: (int, int)->int)->int{
  ans := A[count - 1];
  count = count - 1;
  while(count){
    count = count -1;
    ans = f(ans, A[count]);
  }
  return ans;
}

add := (a: int, b: int)-> int{
  return a + b;
}

successor := (a: int)-> int{
  return a + 1;
}

map := (A: int[], count: int, f:(int)->int, B: int[])->void{
  while(count){
    count = count - 1;
    B[count] = f(A[count]);
  }

  return;
}

main := ()->int{
  a : int[2];
  a[0] = 1;
  a[1] = 2;

  printf("a = [%d, %d]\n", a[0], a[1]);

  printf("aggregate(a, 2, add)=%d\n", aggregate(a,2,add));

  d : int[2];
  map(a, 2, successor, d);
  printf("d = map a w/ successor = [%d, %d]\n", d[0], d[1]);

  printf("aggregate(d, 2, add)=%d\n", aggregate(d,2,add));

  return 0;
}
