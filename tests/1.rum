// Comments

/* Multi line comments
and /*nested*/ comments*/

// Imports
import "base.rum"

section := (name: string)->void{
  printf("\n\n========\n%s\n========\n\n", name);
  return;
}

vardiac_test := ()->void{
  vardtest := (v: ... int)->void{
    printf("inside vardiac function\n");
    return;
  }
  vardtest();
  vardtest(1,2,3);
  return;
}

branch_test := () -> void{
  if(1)
    printf("inside if\n");

  if(1)
    if(0)
      printf("not gonna happen\n");
    else
      printf("inside else of the if\n");

  counter := 3;
  while(counter){
    printf("counter=%d\n", counter);
    counter = counter - 1;
  }

  return;
}

binop_test := (a: int, b: int)-> void{
  printf("a+b=%d\n", a+b);
  printf("a*b=%d\n", a*b);
  printf("a%b=%d\n", a%b);
  printf("a+a*b=%d\n", a+a*b);
  return;
}

MyStruct : struct{
  id: int = 3;
  b : int;
}

struct_test := () -> void{
  t: MyStruct;
  t.b = 12;
  printf("t.b=%d\n", t.b);
  printf("t.id=%d\n", t.id);
  return;
}

casting_test := () -> void{
  a: u8;
  b: u16;
  c: u32;
  d: u64;

  d = 5;
  a = d -> u8;
  b = d->s16;
  b = d -> s16;
  c = d . as(s32);

  printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);

  f_1: f32;
  f_2: f64;

  f_1 = 30;
  f_2 = 21;

  printf("The float32 is %f\n", f_1->f64);
  printf("The float64 is %f\n", f_2);

  return;
}

pointer_test := () -> void{
  a := 3;
  printf("a = %d\n", a);
  b : *int;
  b = &a;
  *b = 1;
  printf("*b = %d\n", *b);
  c : **int = &b;
  * *c = 4;
  printf("a = %d\n", a);
  return;
}

array_test := () -> void{
  arr : int[10];
  x := 3;

  arr[2] = 1;
  printf("a[2]=%d\n", arr[2]);

  a := 2;
  arr[a] = 4;

  printf("a[2]=%d\n", arr[a]);

  return;
}

defered_test := () -> void{
  defer if(1) printf("In if1\n");

  if(1){
    printf("in if2\n");
    defer printf("Defered in if2\n");
    printf("in if2\n");
  } else {
    defer printf("This shouldn't happen\n");
  }

  p := 2;

  defer printf("p=%d\n", p);

  p = 10;

  return;
}

heap_test := () -> void{
  ptr : *int;
  ptr = malloc(sizeof(int))->*int;
  *ptr = 2;

  printf("*ptr=%d\n", *ptr);

  printf("sizeof(s8)=%d\n", sizeof(s8));
  printf("sizeof(s64)=%d\n", sizeof(s64));
  printf("sizeof(MyStruct)=%d\n", sizeof(MyStruct));
  printf("sizeof(*MyStruct)=%d\n", sizeof(*MyStruct));

  return;
}

function_var_test := () -> void{
  add := (a: int, b: int)->int{
    return a + b;
    }

  mult := (a: int, b: int)->int{
    return a * b;
  }

  f : (int, int)-> int;
  f = add;
  printf("add(1,2)=%d\n", f(1,2));

  f = mult;
  printf("mult(1,2)=%d\n", f(1,2));
  return;
}

array_in_args_test := ()->void{

  add_one_to_array := (A: int[], count: int)->void{
    while(count){
      count = count - 1;
      A[count] = A[count] + 1;
    }
    return;
  }

  a: int[2];
  a[0] = 1;
  a[1] = 2;
  printf("a = [%d, %d]\n", a[0], a[1]);

  add_one_to_array(a, 2);

  printf("a = [%d, %d]\n", a[0], a[1]);

  c:=2;

  e: int[c];
  e[0] = 12;
  e[1] = 3;

  printf("e = [%d, %d]\n", e[0], e[1]);
  add_one_to_array(e, 2);
  printf("e = [%d, %d]\n", e[0], e[1]);

  d: int[];
  d = a;
  d[0] = 12;
  d[1] = 3;

  printf("a = [%d, %d]\n", a[0], a[1]);
  printf("d = [%d, %d]\n", d[0], d[1]);

  add_one_to_array(d, 2);

  printf("a = [%d, %d]\n", a[0], a[1]);
  printf("d = [%d, %d]\n", d[0], d[1]);

  return;
}

functional_test := () -> void{
  add := (a: int, b: int)->int{
    return a + b;
  }

  successor := (a: int)-> int{
    return a + 1;
  }

  map := (A: int[], count: int, f:(int)->int, B: int[])->void{
    while(count){
      count = count - 1;
      B[count] = f(A[count]);
  }

    return;
  }

  aggregate := (A: int[], count: int, f: (int, int)->int)->int{
    ans := A[count - 1];
    count = count - 1;
    while(count){
      count = count -1;
      ans = f(ans, A[count]);
    }
    return ans;
  }

  a : int[2];
  a[0] = 1;
  a[1] = 2;

  printf("a = [%d, %d]\n", a[0], a[1]);

  printf("aggregate(a, 2, add)=%d\n", aggregate(a,2,add));

  d : int[2];
  map(a, 2, successor, d);
  printf("d = map a w/ successor = [%d, %d]\n", d[0], d[1]);

  printf("aggregate(d, 2, add)=%d\n", aggregate(d,2,add));

  return;
}

pointer_arithmetic_test := () -> void{
  a : int[2];
  a[0] = 1;
  a[1] = 2;

  printf("a[0]=%d\n", a[0]);
  printf("a[1]=%d\n", a[1]);

  b : *int;
  b = &a[0];

  b = a;
  d := b + 1;

  *b = 3;
  *d = 4;

  printf("a[0]=%d\n", a[0]);
  printf("a[1]=%d\n", a[1]);

  *(d-1) = 5;
  *(b+1) = 6;

  printf("a[0]=%d\n", a[0]);
  printf("a[1]=%d\n", a[1]);

  return;
}

main := () -> int{
  section("vardiac");
  vardiac_test();

  section("branch");
  branch_test();

  section("bin-op");
  binop_test(3, 90);

  section("struct");
  struct_test();

  section("casting");
  casting_test();

  section("pointer");
  pointer_test();

  section("arrays");
  array_test();

  section("defered");
  defered_test();

  section("heap");
  heap_test();

  section("function variables");
  function_var_test();

  section("array in arguments");
  array_in_args_test();

  section("functional properties");
  functional_test();

  section("pointer arithmetic");
  pointer_arithmetic_test();

  return 0;
}

@compile
compile_test := () -> int{
  printf("Welcome to compile time!\n");
  // A return value of 0 means okay
  return 0;
}

@compile
second_compile_test := () -> int{
  printf("Fail\n");
  // A return value of 1 is a warning
  // A return value of anything other than 0 or 1 means fatal error
  return 1;
}