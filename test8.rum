import test_import
import compiler
import ast
// import compiler_parser


HiParseRule: struct{}

HiParseRule.parse := (c: *Compiler, s: *Source, pos: int)->*ParseResult{
  idp := c.getParser("id");

  id := idp.parse(c, s, pos);


  if(id){
    ids := (id.get("id")) -> string;
    if(!streq(ids, "hi")){
      id = 0 -> *ParseResult;
    }
  }

  return id;
}

HiParseRule.genAST := (c: *Compiler, token: *ParseResult) -> *C_AST{
  fcall := c.createFCallStmt();
  fcall.setId("printf");
  s := c.createCString();
  s.setValue("hello, world! from many levels deep!\n");
  fcall.addArg(s);
  return fcall;
}

ComplexRule: struct{}

ComplexRule.genAST := (c: *Compiler, token: *ParseResult) -> *C_AST{
  fcall := c.createFCallStmt();
  fcall.setId("printf");
  s := c.createCString();
  v :*u8 = token.get("id");
  //v = v + 3;
  v = strcat(strcat("You defined ", v), "\n");
  s.setValue(v);
  fcall.addArg(s);
  return fcall;
}

ComplexRule.parse := (c: *Compiler, s: *Source, pos: int)->*ParseResult{
  idp := c.getParser("id");

  hikeyword := idp.parse(c, s, pos);
  id := idp.parseAfter(hikeyword);

  if(id){
    hik := (hikeyword.get("id"))->string;
    if(!streq("say", hik)){
      id = 0;
    }
  }
  return id;
}

DefPrintRule: struct{}
DefPrintRule.parse := (c: *Compiler, s: *Source, pos: int) -> *ParseResult{
  idp := c.getParser("id");

  kw := idp.parse(c, s, pos);
  id := idp.parseAfter(kw);

  if(id){
    k := (kw.get("id"))->string;
    if(!streq(k, "DefPrint")){
      id = 0;
    }
  }

  return id;
}
DefPrintRule.genAST := (c: *Compiler, token: *ParseResult) -> *C_AST{
  m := c.createFunction();

  tname : *u8 = token.get("id");

  m.setId(strcat(tname, "$print"));
  printf("Set the name of fucntion to %s\n", m.getId());
  m.setReturntype(c.createPrimitiveType("unit"));

  ps := c.createFCallStmt();
  ps.setId("printf");
  cs := c.createCString();
  cs.setValue(strcat("< ", strcat(tname, ".id = %d>\n")));
  ps.addArg(cs);
  v_self := c.createVariableValue("self");
  ma := c.createMemAccess(v_self, "id");
  ps.addArg(ma);
  m.addStmt(ps);
  rs := c.createReturn(0);
  m.addStmt(rs);

  method := c.createMethod(tname, "print", m);

  printf("Method is %d\n", method);

  return method;
}

@compile
add_statement := (c: *Compiler) -> int{

/* TODO potentially do this, so we have access to inner things in the parse method
  h: *HiParseRule = malloc(sizeof HiParseRule);
  c.registerParser("statement", "HiParseRule", h);
*/

  c.registerParser("statement", "HiParseRule");
  c.registerParser("statement", "ComplexRule");

  c.registerParser("top", "DefPrintRule");

  return 0;
}

T: struct{
  id: int;
}

DefPrint T

main := () -> int{
  hi
  say Sajjad
  say Rumi

  t : T;
  t. id = 5;

  //T_print(t);
  t.print();

  return 0;
}